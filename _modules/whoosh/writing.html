<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>whoosh.writing &mdash; Whoosh-Reloaded 2.7.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Whoosh-Reloaded
          </a>
              <div class="version">
                2.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../releases/index.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction to Whoosh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../schema.html">Designing a schema</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../indexing.html">How to index documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../searching.html">How to search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parsing.html">Parsing user queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../querylang.html">The default query language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dates.html">Indexing and parsing dates/times</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../query.html">Query objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../analysis.html">About analyzers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stemming.html">Stemming, variations, and accent folding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ngrams.html">Indexing and searching N-grams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../facets.html">Sorting and faceting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../highlight.html">How to create highlighted search result excerpts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../keywords.html">Query expansion and Key word extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spelling.html">“Did you mean… ?” Correcting errors in user queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fieldcaches.html">Field caches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../batch.html">Tips for speeding up batch indexing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../threads.html">Concurrency, locking, and versioning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nested.html">Indexing and searching document hierarchies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../recipes.html">Whoosh recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/api.html">Whoosh API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tech/index.html">Technical notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Whoosh-Reloaded</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">whoosh.writing</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for whoosh.writing</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2007 Matt Chaput. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1">#    1. Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#       this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#    2. Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#       notice, this list of conditions and the following disclaimer in the</span>
<span class="c1">#       documentation and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY MATT CHAPUT ``AS IS&#39;&#39; AND ANY EXPRESS OR</span>
<span class="c1"># IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="c1"># MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO</span>
<span class="c1"># EVENT SHALL MATT CHAPUT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="c1"># INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="c1"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,</span>
<span class="c1"># OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="c1"># LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="c1"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</span>
<span class="c1"># EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1"># The views and conclusions contained in the software and documentation are</span>
<span class="c1"># those of the authors and should not be interpreted as representing official</span>
<span class="c1"># policies, either expressed or implied, of Matt Chaput.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">with_statement</span>
<span class="kn">import</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_right</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">columns</span>
<span class="kn">from</span> <span class="nn">whoosh.compat</span> <span class="kn">import</span> <span class="n">abstractmethod</span><span class="p">,</span> <span class="n">bytes_type</span>
<span class="kn">from</span> <span class="nn">whoosh.externalsort</span> <span class="kn">import</span> <span class="n">SortingPool</span>
<span class="kn">from</span> <span class="nn">whoosh.fields</span> <span class="kn">import</span> <span class="n">UnknownFieldError</span>
<span class="kn">from</span> <span class="nn">whoosh.index</span> <span class="kn">import</span> <span class="n">LockError</span>
<span class="kn">from</span> <span class="nn">whoosh.util</span> <span class="kn">import</span> <span class="n">fib</span><span class="p">,</span> <span class="n">random_name</span>
<span class="kn">from</span> <span class="nn">whoosh.util.filelock</span> <span class="kn">import</span> <span class="n">try_for</span>
<span class="kn">from</span> <span class="nn">whoosh.util.text</span> <span class="kn">import</span> <span class="n">utf8encode</span>


<span class="c1"># Exceptions</span>


<div class="viewcode-block" id="IndexingError"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexingError">[docs]</a><span class="k">class</span> <span class="nc">IndexingError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<span class="c1"># Document grouping context manager</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">groupmanager</span><span class="p">(</span><span class="n">writer</span><span class="p">):</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">start_group</span><span class="p">()</span>
    <span class="k">yield</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">end_group</span><span class="p">()</span>


<span class="c1"># Merge policies</span>

<span class="c1"># A merge policy is a callable that takes the Index object, the SegmentWriter</span>
<span class="c1"># object, and the current segment list (not including the segment being</span>
<span class="c1"># written), and returns an updated segment list (not including the segment</span>
<span class="c1"># being written).</span>


<span class="k">def</span> <span class="nf">NO_MERGE</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This policy does not merge any existing segments.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">segments</span>


<span class="k">def</span> <span class="nf">MERGE_SMALL</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This policy merges small segments, where &quot;small&quot; is defined using a</span>
<span class="sd">    heuristic based on the fibonacci sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">whoosh.reading</span> <span class="kn">import</span> <span class="n">SegmentReader</span>

    <span class="n">unchanged_segments</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">segments_to_merge</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">sorted_segment_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">doc_count_all</span><span class="p">())</span>
    <span class="n">total_docs</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">merge_point_found</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_segment_list</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">doc_count_all</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">total_docs</span> <span class="o">+=</span> <span class="n">count</span>

        <span class="k">if</span> <span class="n">merge_point_found</span><span class="p">:</span>  <span class="c1"># append the remaining to unchanged</span>
            <span class="n">unchanged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># look for a merge point</span>
            <span class="n">segments_to_merge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># merge every segment up to the merge point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">total_docs</span> <span class="o">&lt;</span> <span class="n">fib</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">):</span>
                <span class="n">merge_point_found</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">merge_point_found</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments_to_merge</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">segments_to_merge</span><span class="p">:</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="n">SegmentReader</span><span class="p">(</span><span class="n">writer</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">writer</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
            <span class="n">reader</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">unchanged_segments</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">segments</span>


<span class="k">def</span> <span class="nf">OPTIMIZE</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This policy merges all existing segments.&quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">whoosh.reading</span> <span class="kn">import</span> <span class="n">SegmentReader</span>

    <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">SegmentReader</span><span class="p">(</span><span class="n">writer</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">writer</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
        <span class="n">reader</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">CLEAR</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This policy DELETES all existing segments and only writes the new</span>
<span class="sd">    segment.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[]</span>


<span class="c1"># Customized sorting pool for postings</span>


<span class="k">class</span> <span class="nc">PostingPool</span><span class="p">(</span><span class="n">SortingPool</span><span class="p">):</span>
    <span class="c1"># Subclass whoosh.externalsort.SortingPool to use knowledge of</span>
    <span class="c1"># postings to set run size in bytes instead of items</span>

    <span class="n">namechars</span> <span class="o">=</span> <span class="s2">&quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tempstore</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">limitmb</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">SortingPool</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tempstore</span> <span class="o">=</span> <span class="n">tempstore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limitmb</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentsize</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_new_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.run&quot;</span> <span class="o">%</span> <span class="n">random_name</span><span class="p">()</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tempstore</span><span class="o">.</span><span class="n">create_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">raw_file</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">_open_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tempstore</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">raw_file</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_remove_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tempstore</span><span class="o">.</span><span class="n">delete_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="c1"># item = (fieldname, tbytes, docnum, weight, vbytes)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bytes_type</span><span class="p">),</span> <span class="s2">&quot;tbytes=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">bytes_type</span><span class="p">),</span> <span class="s2">&quot;vbytes=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">28</span>
            <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">5</span>  <span class="c1"># tuple = 28 + 4 * length</span>
            <span class="o">+</span> <span class="mi">21</span>
            <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># fieldname = str = 21 + length</span>
            <span class="o">+</span> <span class="mi">26</span>
            <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># text = unicode = 26 + 2 * length</span>
            <span class="o">+</span> <span class="mi">18</span>  <span class="c1"># docnum = long = 18</span>
            <span class="o">+</span> <span class="mi">16</span>  <span class="c1"># weight = float = 16</span>
            <span class="o">+</span> <span class="mi">21</span>
            <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># valuestring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentsize</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentsize</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iter_postings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This is just an alias for items() to be consistent with the</span>
        <span class="c1"># iter_postings()/add_postings() interface of a lot of other classes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">SortingPool</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentsize</span> <span class="o">=</span> <span class="mi">0</span>


<span class="c1"># Writer base class</span>


<div class="viewcode-block" id="IndexWriter"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter">[docs]</a><span class="k">class</span> <span class="nc">IndexWriter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;High-level object for writing to an index.</span>

<span class="sd">    To get a writer for a particular index, call</span>
<span class="sd">    :meth:`~whoosh.index.Index.writer` on the Index object.</span>

<span class="sd">    &gt;&gt;&gt; writer = myindex.writer()</span>

<span class="sd">    You can use this object as a context manager. If an exception is thrown</span>
<span class="sd">    from within the context it calls :meth:`~IndexWriter.cancel` to clean up</span>
<span class="sd">    temporary files, otherwise it calls :meth:`~IndexWriter.commit` when the</span>
<span class="sd">    context exits.</span>

<span class="sd">    &gt;&gt;&gt; with myindex.writer() as w:</span>
<span class="sd">    ...     w.add_document(title=&quot;First document&quot;, content=&quot;Hello there.&quot;)</span>
<span class="sd">    ...     w.add_document(title=&quot;Second document&quot;, content=&quot;This is easy!&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exc_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<div class="viewcode-block" id="IndexWriter.group"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.group">[docs]</a>    <span class="k">def</span> <span class="nf">group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a context manager that calls</span>
<span class="sd">        :meth:`~IndexWriter.start_group` and :meth:`~IndexWriter.end_group` for</span>
<span class="sd">        you, allowing you to use a ``with`` statement to group hierarchical</span>
<span class="sd">        documents::</span>

<span class="sd">            with myindex.writer() as w:</span>
<span class="sd">                with w.group():</span>
<span class="sd">                    w.add_document(kind=&quot;class&quot;, name=&quot;Accumulator&quot;)</span>
<span class="sd">                    w.add_document(kind=&quot;method&quot;, name=&quot;add&quot;)</span>
<span class="sd">                    w.add_document(kind=&quot;method&quot;, name=&quot;get_result&quot;)</span>
<span class="sd">                    w.add_document(kind=&quot;method&quot;, name=&quot;close&quot;)</span>

<span class="sd">                with w.group():</span>
<span class="sd">                    w.add_document(kind=&quot;class&quot;, name=&quot;Calculator&quot;)</span>
<span class="sd">                    w.add_document(kind=&quot;method&quot;, name=&quot;add&quot;)</span>
<span class="sd">                    w.add_document(kind=&quot;method&quot;, name=&quot;multiply&quot;)</span>
<span class="sd">                    w.add_document(kind=&quot;method&quot;, name=&quot;get_result&quot;)</span>
<span class="sd">                    w.add_document(kind=&quot;method&quot;, name=&quot;close&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">groupmanager</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexWriter.start_group"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.start_group">[docs]</a>    <span class="k">def</span> <span class="nf">start_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start indexing a group of hierarchical documents. The backend should</span>
<span class="sd">        ensure that these documents are all added to the same segment::</span>

<span class="sd">            with myindex.writer() as w:</span>
<span class="sd">                w.start_group()</span>
<span class="sd">                w.add_document(kind=&quot;class&quot;, name=&quot;Accumulator&quot;)</span>
<span class="sd">                w.add_document(kind=&quot;method&quot;, name=&quot;add&quot;)</span>
<span class="sd">                w.add_document(kind=&quot;method&quot;, name=&quot;get_result&quot;)</span>
<span class="sd">                w.add_document(kind=&quot;method&quot;, name=&quot;close&quot;)</span>
<span class="sd">                w.end_group()</span>

<span class="sd">                w.start_group()</span>
<span class="sd">                w.add_document(kind=&quot;class&quot;, name=&quot;Calculator&quot;)</span>
<span class="sd">                w.add_document(kind=&quot;method&quot;, name=&quot;add&quot;)</span>
<span class="sd">                w.add_document(kind=&quot;method&quot;, name=&quot;multiply&quot;)</span>
<span class="sd">                w.add_document(kind=&quot;method&quot;, name=&quot;get_result&quot;)</span>
<span class="sd">                w.add_document(kind=&quot;method&quot;, name=&quot;close&quot;)</span>
<span class="sd">                w.end_group()</span>

<span class="sd">        A more convenient way to group documents is to use the</span>
<span class="sd">        :meth:`~IndexWriter.group` method and the ``with`` statement.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span></div>

<div class="viewcode-block" id="IndexWriter.end_group"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.end_group">[docs]</a>    <span class="k">def</span> <span class="nf">end_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finish indexing a group of hierarchical documents. See</span>
<span class="sd">        :meth:`~IndexWriter.start_group`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span></div>

<div class="viewcode-block" id="IndexWriter.add_field"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.add_field">[docs]</a>    <span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">fieldtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a field to the index&#39;s schema.</span>

<span class="sd">        :param fieldname: the name of the field to add.</span>
<span class="sd">        :param fieldtype: an instantiated :class:`whoosh.fields.FieldType`</span>
<span class="sd">            object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">fieldtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexWriter.remove_field"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.remove_field">[docs]</a>    <span class="k">def</span> <span class="nf">remove_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes the named field from the index&#39;s schema. Depending on the</span>
<span class="sd">        backend implementation, this may or may not actually remove existing</span>
<span class="sd">        data for the field from the index. Optimizing the index should always</span>
<span class="sd">        clear out existing data for a removed field.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexWriter.reader"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.reader">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a reader for the existing index.&quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">searcher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh.searching</span> <span class="kn">import</span> <span class="n">Searcher</span>

        <span class="k">return</span> <span class="n">Searcher</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="IndexWriter.delete_by_term"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.delete_by_term">[docs]</a>    <span class="k">def</span> <span class="nf">delete_by_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">searcher</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes any documents containing &quot;term&quot; in the &quot;fieldname&quot; field.</span>
<span class="sd">        This is useful when you have an indexed field containing a unique ID</span>
<span class="sd">        (such as &quot;pathname&quot;) for each document.</span>

<span class="sd">        :returns: the number of documents deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">whoosh.query</span> <span class="kn">import</span> <span class="n">Term</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delete_by_query</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">searcher</span><span class="o">=</span><span class="n">searcher</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexWriter.delete_by_query"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.delete_by_query">[docs]</a>    <span class="k">def</span> <span class="nf">delete_by_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">searcher</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes any documents matching a query object.</span>

<span class="sd">        :returns: the number of documents deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">searcher</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">searcher</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">docnum</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">docs_for_query</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">for_deletion</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_document</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">searcher</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">count</span></div>

<div class="viewcode-block" id="IndexWriter.delete_document"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.delete_document">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">delete_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docnum</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes a document by number.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="IndexWriter.add_document"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.add_document">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">add_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">fields</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The keyword arguments map field names to the values to index/store::</span>

<span class="sd">            w = myindex.writer()</span>
<span class="sd">            w.add_document(path=u&quot;/a&quot;, title=u&quot;First doc&quot;, text=u&quot;Hello&quot;)</span>
<span class="sd">            w.commit()</span>

<span class="sd">        Depending on the field type, some fields may take objects other than</span>
<span class="sd">        unicode strings. For example, NUMERIC fields take numbers, and DATETIME</span>
<span class="sd">        fields take ``datetime.datetime`` objects::</span>

<span class="sd">            from datetime import datetime, timedelta</span>
<span class="sd">            from whoosh import index</span>
<span class="sd">            from whoosh.fields import *</span>

<span class="sd">            schema = Schema(date=DATETIME, size=NUMERIC(float), content=TEXT)</span>
<span class="sd">            myindex = index.create_in(&quot;indexdir&quot;, schema)</span>

<span class="sd">            w = myindex.writer()</span>
<span class="sd">            w.add_document(date=datetime.now(), size=5.5, content=u&quot;Hello&quot;)</span>
<span class="sd">            w.commit()</span>

<span class="sd">        Instead of a single object (i.e., unicode string, number, or datetime),</span>
<span class="sd">        you can supply a list or tuple of objects. For unicode strings, this</span>
<span class="sd">        bypasses the field&#39;s analyzer. For numbers and dates, this lets you add</span>
<span class="sd">        multiple values for the given field::</span>

<span class="sd">            date1 = datetime.now()</span>
<span class="sd">            date2 = datetime(2005, 12, 25)</span>
<span class="sd">            date3 = datetime(1999, 1, 1)</span>
<span class="sd">            w.add_document(date=[date1, date2, date3], size=[9.5, 10],</span>
<span class="sd">                           content=[u&quot;alfa&quot;, u&quot;bravo&quot;, u&quot;charlie&quot;])</span>

<span class="sd">        For fields that are both indexed and stored, you can specify an</span>
<span class="sd">        alternate value to store using a keyword argument in the form</span>
<span class="sd">        &quot;_stored_&lt;fieldname&gt;&quot;. For example, if you have a field named &quot;title&quot;</span>
<span class="sd">        and you want to index the text &quot;a b c&quot; but store the text &quot;e f g&quot;, use</span>
<span class="sd">        keyword arguments like this::</span>

<span class="sd">            writer.add_document(title=u&quot;a b c&quot;, _stored_title=u&quot;e f g&quot;)</span>

<span class="sd">        You can boost the weight of all terms in a certain field by specifying</span>
<span class="sd">        a ``_&lt;fieldname&gt;_boost`` keyword argument. For example, if you have a</span>
<span class="sd">        field named &quot;content&quot;, you can double the weight of this document for</span>
<span class="sd">        searches in the &quot;content&quot; field like this::</span>

<span class="sd">            writer.add_document(content=&quot;a b c&quot;, _title_boost=2.0)</span>

<span class="sd">        You can boost every field at once using the ``_boost`` keyword. For</span>
<span class="sd">        example, to boost fields &quot;a&quot; and &quot;b&quot; by 2.0, and field &quot;c&quot; by 3.0::</span>

<span class="sd">            writer.add_document(a=&quot;alfa&quot;, b=&quot;bravo&quot;, c=&quot;charlie&quot;,</span>
<span class="sd">                                _boost=2.0, _c_boost=3.0)</span>

<span class="sd">        Note that some scoring algroithms, including Whoosh&#39;s default BM25F,</span>
<span class="sd">        do not work with term weights less than 1, so you should generally not</span>
<span class="sd">        use a boost factor less than 1.</span>

<span class="sd">        See also :meth:`Writer.update_document`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">add_reader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_doc_boost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;_boost&quot;</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="s2">&quot;_boost&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">_field_boost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="n">boostkw</span> <span class="o">=</span> <span class="s2">&quot;_</span><span class="si">%s</span><span class="s2">_boost&quot;</span> <span class="o">%</span> <span class="n">fieldname</span>
        <span class="k">if</span> <span class="n">boostkw</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="n">boostkw</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">_unique_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="c1"># Check which of the supplied fields are unique</span>
        <span class="n">unique_fields</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">name</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fields</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">unique</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">unique_fields</span>

<div class="viewcode-block" id="IndexWriter.update_document"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.update_document">[docs]</a>    <span class="k">def</span> <span class="nf">update_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">fields</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The keyword arguments map field names to the values to index/store.</span>

<span class="sd">        This method adds a new document to the index, and automatically deletes</span>
<span class="sd">        any documents with the same values in any fields marked &quot;unique&quot; in the</span>
<span class="sd">        schema::</span>

<span class="sd">            schema = fields.Schema(path=fields.ID(unique=True, stored=True),</span>
<span class="sd">                                   content=fields.TEXT)</span>
<span class="sd">            myindex = index.create_in(&quot;index&quot;, schema)</span>

<span class="sd">            w = myindex.writer()</span>
<span class="sd">            w.add_document(path=u&quot;/&quot;, content=u&quot;Mary had a lamb&quot;)</span>
<span class="sd">            w.commit()</span>

<span class="sd">            w = myindex.writer()</span>
<span class="sd">            w.update_document(path=u&quot;/&quot;, content=u&quot;Mary had a little lamb&quot;)</span>
<span class="sd">            w.commit()</span>

<span class="sd">            assert myindex.doc_count() == 1</span>

<span class="sd">        It is safe to use ``update_document`` in place of ``add_document``; if</span>
<span class="sd">        there is no existing document to replace, it simply does an add.</span>

<span class="sd">        You cannot currently pass a list or tuple of values to a &quot;unique&quot;</span>
<span class="sd">        field.</span>

<span class="sd">        Because this method has to search for documents with the same unique</span>
<span class="sd">        fields and delete them before adding the new document, it is slower</span>
<span class="sd">        than using ``add_document``.</span>

<span class="sd">        * Marking more fields &quot;unique&quot; in the schema will make each</span>
<span class="sd">          ``update_document`` call slightly slower.</span>

<span class="sd">        * When you are updating multiple documents, it is faster to batch</span>
<span class="sd">          delete all changed documents and then use ``add_document`` to add</span>
<span class="sd">          the replacements instead of using ``update_document``.</span>

<span class="sd">        Note that this method will only replace a *committed* document;</span>
<span class="sd">        currently it cannot replace documents you&#39;ve added to the IndexWriter</span>
<span class="sd">        but haven&#39;t yet committed. For example, if you do this:</span>

<span class="sd">        &gt;&gt;&gt; writer.update_document(unique_id=u&quot;1&quot;, content=u&quot;Replace me&quot;)</span>
<span class="sd">        &gt;&gt;&gt; writer.update_document(unique_id=u&quot;1&quot;, content=u&quot;Replacement&quot;)</span>

<span class="sd">        ...this will add two documents with the same value of ``unique_id``,</span>
<span class="sd">        instead of the second document replacing the first.</span>

<span class="sd">        See :meth:`Writer.add_document` for information on</span>
<span class="sd">        ``_stored_&lt;fieldname&gt;``, ``_&lt;fieldname&gt;_boost``, and ``_boost`` keyword</span>
<span class="sd">        arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Delete the set of documents matching the unique terms</span>
        <span class="n">unique_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique_fields</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="p">()</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">uniqueterms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">fields</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">unique_fields</span><span class="p">]</span>
                <span class="n">docs</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_find_unique</span><span class="p">(</span><span class="n">uniqueterms</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">docnum</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delete_document</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span>

        <span class="c1"># Add the given fields</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_document</span><span class="p">(</span><span class="o">**</span><span class="n">fields</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexWriter.commit"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.commit">[docs]</a>    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finishes writing and unlocks the index.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="IndexWriter.cancel"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.IndexWriter.cancel">[docs]</a>    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cancels any documents/deletions added by this object</span>
<span class="sd">        and unlocks the index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<span class="c1"># Codec-based writer</span>


<span class="k">class</span> <span class="nc">SegmentWriter</span><span class="p">(</span><span class="n">IndexWriter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ix</span><span class="p">,</span>
        <span class="n">poolclass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">delay</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">_lk</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">limitmb</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
        <span class="n">docbase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">codec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">compound</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="c1"># Lock the index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writelock</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">_lk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writelock</span> <span class="o">=</span> <span class="n">ix</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="s2">&quot;WRITELOCK&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">try_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">writelock</span><span class="o">.</span><span class="n">acquire</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">LockError</span>

        <span class="k">if</span> <span class="n">codec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">whoosh.codec</span> <span class="kn">import</span> <span class="n">default_codec</span>

            <span class="n">codec</span> <span class="o">=</span> <span class="n">default_codec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">codec</span> <span class="o">=</span> <span class="n">codec</span>

        <span class="c1"># Get info from the index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">storage</span> <span class="o">=</span> <span class="n">ix</span><span class="o">.</span><span class="n">storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexname</span> <span class="o">=</span> <span class="n">ix</span><span class="o">.</span><span class="n">indexname</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">ix</span><span class="o">.</span><span class="n">_read_toc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generation</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">generation</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">schema</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">docbase</span> <span class="o">=</span> <span class="n">docbase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_doc_offsets</span><span class="p">()</span>

        <span class="c1"># Internals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tempstorage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">temp_storage</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.tmp&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexname</span><span class="p">)</span>
        <span class="n">newsegment</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">new_segment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newsegment</span> <span class="o">=</span> <span class="n">newsegment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compound</span> <span class="o">=</span> <span class="n">compound</span> <span class="ow">and</span> <span class="n">newsegment</span><span class="o">.</span><span class="n">should_assemble</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_added</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">PostingPool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tempstorage</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">newsegment</span><span class="p">,</span> <span class="n">limitmb</span><span class="o">=</span><span class="n">limitmb</span><span class="p">)</span>

        <span class="c1"># Set up writers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perdocwriter</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">per_document_writer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">newsegment</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldwriter</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">field_writer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">newsegment</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">merge</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mergetype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_searcher</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Author: Ronald Evers</span>
        <span class="c1"># Origin bitbucket issue: https://bitbucket.org/mchaput/whoosh/issues/483</span>
        <span class="c1"># newsegment might not be set due to LockError</span>
        <span class="c1"># so use getattr to be safe</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;newsegment&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_check_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">IndexingError</span><span class="p">(</span><span class="s2">&quot;This writer is closed&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_doc_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_doc_offsets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">base</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_doc_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="n">base</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">doc_count_all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_document_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docnum</span><span class="p">):</span>
        <span class="c1"># Returns the index.Segment object containing the given document</span>
        <span class="c1"># number.</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doc_offsets</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">docnum</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_segment_and_docnum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docnum</span><span class="p">):</span>
        <span class="c1"># Returns an (index.Segment, segment_docnum) pair for the segment</span>
        <span class="c1"># containing the given document number.</span>

        <span class="n">segmentnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_document_segment</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doc_offsets</span><span class="p">[</span><span class="n">segmentnum</span><span class="p">]</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">segmentnum</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">segment</span><span class="p">,</span> <span class="n">docnum</span> <span class="o">-</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="nf">_process_posts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">startdoc</span><span class="p">,</span> <span class="n">docmap</span><span class="p">):</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">for</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">docnum</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">vbytes</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">docmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newdoc</span> <span class="o">=</span> <span class="n">docmap</span><span class="p">[</span><span class="n">docnum</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newdoc</span> <span class="o">=</span> <span class="n">startdoc</span> <span class="o">+</span> <span class="n">docnum</span>

            <span class="k">yield</span> <span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">newdoc</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">vbytes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">temp_storage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tempstorage</span>

    <span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">fieldspec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_state</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_added</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Can&#39;t modify schema after adding data to writer&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SegmentWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">fieldspec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_state</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_added</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Can&#39;t modify schema after adding data to writer&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SegmentWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">remove_field</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_deletions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the current index has documents that are marked deleted</span>
<span class="sd">        but haven&#39;t been optimized out of the index yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">has_deletions</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docnum</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_state</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">docnum</span> <span class="o">&gt;=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">doc_count_all</span><span class="p">()</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IndexingError</span><span class="p">(</span><span class="s2">&quot;No document ID </span><span class="si">%r</span><span class="s2"> in this index&quot;</span> <span class="o">%</span> <span class="n">docnum</span><span class="p">)</span>
        <span class="n">segment</span><span class="p">,</span> <span class="n">segdocnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_and_docnum</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span>
        <span class="n">segment</span><span class="o">.</span><span class="n">delete_document</span><span class="p">(</span><span class="n">segdocnum</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="n">delete</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deleted_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: the total number of deleted documents in the index.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">deleted_count</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docnum</span><span class="p">):</span>
        <span class="n">segment</span><span class="p">,</span> <span class="n">segdocnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_and_docnum</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">segment</span><span class="o">.</span><span class="n">is_deleted</span><span class="p">(</span><span class="n">segdocnum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reuse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh.index</span> <span class="kn">import</span> <span class="n">FileIndex</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">FileIndex</span><span class="o">.</span><span class="n">_reader</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generation</span><span class="p">,</span> <span class="n">reuse</span><span class="o">=</span><span class="n">reuse</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">iter_postings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">iter_postings</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_postings_to_pool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">,</span> <span class="n">startdoc</span><span class="p">,</span> <span class="n">docmap</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_posts</span><span class="p">(</span><span class="n">reader</span><span class="o">.</span><span class="n">iter_postings</span><span class="p">(),</span> <span class="n">startdoc</span><span class="p">,</span> <span class="n">docmap</span><span class="p">)</span>
        <span class="n">add_post</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">add</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">add_post</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_postings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">startdoc</span><span class="p">,</span> <span class="n">docmap</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_posts</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">startdoc</span><span class="p">,</span> <span class="n">docmap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldwriter</span><span class="o">.</span><span class="n">add_postings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_per_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldnames</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
        <span class="c1"># Very bad hack: reader should be an IndexReader, but may be a</span>
        <span class="c1"># PerDocumentReader if this is called from multiproc, where the code</span>
        <span class="c1"># tries to be efficient by merging per-doc and terms separately.</span>
        <span class="c1"># TODO: fix this!</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">if</span> <span class="n">reader</span><span class="o">.</span><span class="n">has_deletions</span><span class="p">():</span>
            <span class="n">docmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">docmap</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">pdw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perdocwriter</span>
        <span class="c1"># Open all column readers</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">fieldnames</span><span class="p">:</span>
            <span class="n">fieldobj</span> <span class="o">=</span> <span class="n">schema</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>
            <span class="n">coltype</span> <span class="o">=</span> <span class="n">fieldobj</span><span class="o">.</span><span class="n">column_type</span>
            <span class="k">if</span> <span class="n">coltype</span> <span class="ow">and</span> <span class="n">reader</span><span class="o">.</span><span class="n">has_column</span><span class="p">(</span><span class="n">fieldname</span><span class="p">):</span>
                <span class="n">creader</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">column_reader</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">coltype</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">creader</span><span class="p">,</span> <span class="n">columns</span><span class="o">.</span><span class="n">TranslatingColumnReader</span><span class="p">):</span>
                    <span class="n">creader</span> <span class="o">=</span> <span class="n">creader</span><span class="o">.</span><span class="n">raw_column</span><span class="p">()</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span> <span class="o">=</span> <span class="n">creader</span>

        <span class="k">for</span> <span class="n">docnum</span><span class="p">,</span> <span class="n">stored</span> <span class="ow">in</span> <span class="n">reader</span><span class="o">.</span><span class="n">iter_docs</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">docmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">docmap</span><span class="p">[</span><span class="n">docnum</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">docnum</span>

            <span class="n">pdw</span><span class="o">.</span><span class="n">start_doc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docnum</span><span class="p">)</span>
            <span class="c1"># Set disjunction includes dynamic fields (can be different for each document)</span>
            <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">fieldnames</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stored</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">):</span>
                <span class="n">fieldobj</span> <span class="o">=</span> <span class="n">schema</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">doc_field_length</span><span class="p">(</span><span class="n">docnum</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span>
                <span class="n">pdw</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">fieldobj</span><span class="p">,</span> <span class="n">stored</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fieldname</span><span class="p">),</span> <span class="n">length</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">fieldobj</span><span class="o">.</span><span class="n">vector</span> <span class="ow">and</span> <span class="n">reader</span><span class="o">.</span><span class="n">has_vector</span><span class="p">(</span><span class="n">docnum</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="n">docnum</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">fieldobj</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>
                    <span class="n">pdw</span><span class="o">.</span><span class="n">add_vector_matcher</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">fieldobj</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
                    <span class="n">cv</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">fieldname</span><span class="p">][</span><span class="n">docnum</span><span class="p">]</span>
                    <span class="n">pdw</span><span class="o">.</span><span class="n">add_column_value</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">fieldobj</span><span class="o">.</span><span class="n">column_type</span><span class="p">,</span> <span class="n">cv</span><span class="p">)</span>

            <span class="n">pdw</span><span class="o">.</span><span class="n">finish_doc</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docnum</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">docmap</span>

    <span class="k">def</span> <span class="nf">add_reader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_state</span><span class="p">()</span>
        <span class="n">basedoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">docnum</span>
        <span class="n">ndxnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="n">fname</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">reader</span><span class="o">.</span><span class="n">indexed_field_names</span><span class="p">()</span> <span class="k">if</span> <span class="n">fname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="p">)</span>
        <span class="n">fieldnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">names</span><span class="p">())</span> <span class="o">|</span> <span class="n">ndxnames</span>

        <span class="n">docmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_per_doc</span><span class="p">(</span><span class="n">fieldnames</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_postings_to_pool</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">basedoc</span><span class="p">,</span> <span class="n">docmap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_added</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_check_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">fieldnames</span><span class="p">):</span>
        <span class="c1"># Check if the caller gave us a bogus field</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fieldnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnknownFieldError</span><span class="p">(</span><span class="s2">&quot;No field named </span><span class="si">%r</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">schema</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">add_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">fields</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_state</span><span class="p">()</span>
        <span class="n">perdocwriter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perdocwriter</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">docnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">docnum</span>
        <span class="n">add_post</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">add</span>

        <span class="n">docboost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doc_boost</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
        <span class="n">fieldnames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fields</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_fields</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">fieldnames</span><span class="p">)</span>

        <span class="n">perdocwriter</span><span class="o">.</span><span class="n">start_doc</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">fieldnames</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">field</span> <span class="o">=</span> <span class="n">schema</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>

                <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">indexed</span><span class="p">:</span>
                    <span class="c1"># TODO: Method for adding progressive field values, ie</span>
                    <span class="c1"># setting start_pos/start_char?</span>
                    <span class="n">fieldboost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field_boost</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">docboost</span><span class="p">)</span>
                    <span class="c1"># Ask the field to return a list of (text, weight, vbytes)</span>
                    <span class="c1"># tuples</span>
                    <span class="n">items</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="c1"># Only store the length if the field is marked scorable</span>
                    <span class="n">scorable</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">scorable</span>
                    <span class="c1"># Add the terms to the pool</span>
                    <span class="k">for</span> <span class="n">tbytes</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">vbytes</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">*=</span> <span class="n">fieldboost</span>
                        <span class="k">if</span> <span class="n">scorable</span><span class="p">:</span>
                            <span class="n">length</span> <span class="o">+=</span> <span class="n">freq</span>
                        <span class="n">add_post</span><span class="p">((</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">tbytes</span><span class="p">,</span> <span class="n">docnum</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">vbytes</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">separate_spelling</span><span class="p">():</span>
                    <span class="n">spellfield</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">spelling_fieldname</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">spellable_words</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="n">word</span> <span class="o">=</span> <span class="n">utf8encode</span><span class="p">(</span><span class="n">word</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1"># item = (fieldname, tbytes, docnum, weight, vbytes)</span>
                        <span class="n">add_post</span><span class="p">((</span><span class="n">spellfield</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vbytes</span><span class="p">))</span>

                <span class="n">vformat</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">vector</span>
                <span class="k">if</span> <span class="n">vformat</span><span class="p">:</span>
                    <span class="n">analyzer</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">analyzer</span>
                    <span class="c1"># Call the format&#39;s word_values method to get posting values</span>
                    <span class="n">vitems</span> <span class="o">=</span> <span class="n">vformat</span><span class="o">.</span><span class="n">word_values</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">analyzer</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
                    <span class="c1"># Remove unused frequency field from the tuple</span>
                    <span class="n">vitems</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">vbytes</span><span class="p">)</span> <span class="k">for</span> <span class="n">text</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">vbytes</span> <span class="ow">in</span> <span class="n">vitems</span>
                    <span class="p">)</span>
                    <span class="n">perdocwriter</span><span class="o">.</span><span class="n">add_vector_items</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">vitems</span><span class="p">)</span>

                <span class="c1"># Allow a custom value for stored field/column</span>
                <span class="n">customval</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_stored_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

                <span class="c1"># Add the stored value and length for this field to the per-</span>
                <span class="c1"># document writer</span>
                <span class="n">sv</span> <span class="o">=</span> <span class="n">customval</span> <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">stored</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">perdocwriter</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">sv</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

                <span class="n">column</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">column_type</span>
                <span class="k">if</span> <span class="n">column</span> <span class="ow">and</span> <span class="n">customval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cv</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">to_column_value</span><span class="p">(</span><span class="n">customval</span><span class="p">)</span>
                    <span class="n">perdocwriter</span><span class="o">.</span><span class="n">add_column_value</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">cv</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">perdocwriter</span><span class="o">.</span><span class="n">cancel_doc</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">ex</span>

        <span class="n">perdocwriter</span><span class="o">.</span><span class="n">finish_doc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_added</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docnum</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">doc_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">docnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">docbase</span>

    <span class="k">def</span> <span class="nf">get_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">newsegment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newsegment</span>
        <span class="n">newsegment</span><span class="o">.</span><span class="n">set_doc_count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docnum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newsegment</span>

    <span class="k">def</span> <span class="nf">per_document_reader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">perdocwriter</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Per-doc writer is still open&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">codec</span><span class="o">.</span><span class="n">per_document_reader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segment</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">searcher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># If possible, cache a Searcher that doesn&#39;t close until we want it to.</span>
        <span class="c1"># We have a write lock, nothing is changing. Only cache if kwargs is emtpy</span>
        <span class="c1"># and the SegmentWriter is still open.</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SegmentWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">searcher</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_searcher</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SegmentWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">searcher</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_searcher</span> <span class="o">=</span> <span class="n">s</span>
            <span class="n">s</span><span class="o">.</span><span class="n">_orig_close</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">close</span>  <span class="c1"># called in _finish()</span>
            <span class="n">s</span><span class="o">.</span><span class="n">close</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_searcher</span>

    <span class="c1"># The following methods break out the commit functionality into smaller</span>
    <span class="c1"># pieces to allow MpWriter to call them individually</span>

    <span class="k">def</span> <span class="nf">_merge_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mergetype</span><span class="p">,</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">merge</span><span class="p">):</span>
        <span class="c1"># The writer supports two ways of setting mergetype/optimize/merge:</span>
        <span class="c1"># as attributes or as keyword arguments to commit(). Originally there</span>
        <span class="c1"># were just the keyword arguments, but then I added the ability to use</span>
        <span class="c1"># the writer as a context manager using &quot;with&quot;, so the user no longer</span>
        <span class="c1"># explicitly called commit(), hence the attributes</span>
        <span class="n">mergetype</span> <span class="o">=</span> <span class="n">mergetype</span> <span class="k">if</span> <span class="n">mergetype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergetype</span>
        <span class="n">optimize</span> <span class="o">=</span> <span class="n">optimize</span> <span class="k">if</span> <span class="n">optimize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span>
        <span class="n">merge</span> <span class="o">=</span> <span class="n">merge</span> <span class="k">if</span> <span class="n">merge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge</span>

        <span class="k">if</span> <span class="n">mergetype</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">optimize</span><span class="p">:</span>
            <span class="n">mergetype</span> <span class="o">=</span> <span class="n">OPTIMIZE</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">merge</span><span class="p">:</span>
            <span class="n">mergetype</span> <span class="o">=</span> <span class="n">NO_MERGE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mergetype</span> <span class="o">=</span> <span class="n">MERGE_SMALL</span>

        <span class="c1"># Call the merge policy function. The policy may choose to merge</span>
        <span class="c1"># other segments into this writer&#39;s pool</span>
        <span class="k">return</span> <span class="n">mergetype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_flush_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perdocwriter</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">codec</span><span class="o">.</span><span class="n">length_stats</span><span class="p">:</span>
            <span class="n">pdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_document_reader</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pdr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">postings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">iter_postings</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldwriter</span><span class="o">.</span><span class="n">add_postings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">pdr</span><span class="p">,</span> <span class="n">postings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldwriter</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pdr</span><span class="p">:</span>
            <span class="n">pdr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_close_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">perdocwriter</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">perdocwriter</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldwriter</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fieldwriter</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_assemble_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compound</span><span class="p">:</span>
            <span class="c1"># Assemble the segment files into a compound file</span>
            <span class="n">newsegment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segment</span><span class="p">()</span>
            <span class="n">newsegment</span><span class="o">.</span><span class="n">create_compound_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">)</span>
            <span class="n">newsegment</span><span class="o">.</span><span class="n">compound</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_partial_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># For use by a parent multiprocessing writer: Closes out the segment</span>
        <span class="c1"># but leaves the pool files intact so the parent can access them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_state</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perdocwriter</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldwriter</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># Don&#39;t call self.pool.cleanup()! We want to grab the pool files.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segment</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_finalize_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Finish writing segment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flush_segment</span><span class="p">()</span>
        <span class="c1"># Close segment files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_segment</span><span class="p">()</span>
        <span class="c1"># Assemble compound segment if necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assemble_segment</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segment</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_commit_toc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh.index</span> <span class="kn">import</span> <span class="n">TOC</span><span class="p">,</span> <span class="n">clean_files</span>

        <span class="c1"># Write a new TOC with the new segment list (and delete old files)</span>
        <span class="n">toc</span> <span class="o">=</span> <span class="n">TOC</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generation</span><span class="p">)</span>
        <span class="n">toc</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexname</span><span class="p">)</span>
        <span class="c1"># Delete leftover files</span>
        <span class="n">clean_files</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generation</span><span class="p">,</span> <span class="n">segments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_searcher</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Close the cached Searcher if we have one.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_searcher</span><span class="o">.</span><span class="n">_orig_close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_searcher</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tempstorage</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">writelock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writelock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># self.storage.close()</span>

    <span class="c1"># Finalization methods</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mergetype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">merge</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finishes writing and saves all additions and changes to disk.</span>

<span class="sd">        There are four possible ways to use this method::</span>

<span class="sd">            # Merge small segments but leave large segments, trying to</span>
<span class="sd">            # balance fast commits with fast searching:</span>
<span class="sd">            writer.commit()</span>

<span class="sd">            # Merge all segments into a single segment:</span>
<span class="sd">            writer.commit(optimize=True)</span>

<span class="sd">            # Don&#39;t merge any existing segments:</span>
<span class="sd">            writer.commit(merge=False)</span>

<span class="sd">            # Use a custom merge function</span>
<span class="sd">            writer.commit(mergetype=my_merge_function)</span>

<span class="sd">        :param mergetype: a custom merge function taking a Writer object and</span>
<span class="sd">            segment list as arguments, and returning a new segment list. If you</span>
<span class="sd">            supply a ``mergetype`` function, the values of the ``optimize`` and</span>
<span class="sd">            ``merge`` arguments are ignored.</span>
<span class="sd">        :param optimize: if True, all existing segments are merged with the</span>
<span class="sd">            documents you&#39;ve added to this writer (and the value of the</span>
<span class="sd">            ``merge`` argument is ignored).</span>
<span class="sd">        :param merge: if False, do not merge small segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_state</span><span class="p">()</span>
        <span class="c1"># Merge old segments if necessary</span>
        <span class="n">finalsegments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_segments</span><span class="p">(</span><span class="n">mergetype</span><span class="p">,</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">merge</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_added</span><span class="p">:</span>
            <span class="c1"># Flush the current segment being written and add it to the</span>
            <span class="c1"># list of remaining segments returned by the merge policy</span>
            <span class="c1"># function</span>
            <span class="n">finalsegments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_finalize_segment</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Close segment files</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_segment</span><span class="p">()</span>
        <span class="c1"># Write TOC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_commit_toc</span><span class="p">(</span><span class="n">finalsegments</span><span class="p">)</span>

        <span class="c1"># Final cleanup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finish</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_state</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_segment</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finish</span><span class="p">()</span>


<span class="c1"># Writer wrappers</span>


<div class="viewcode-block" id="AsyncWriter"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter">[docs]</a><span class="k">class</span> <span class="nc">AsyncWriter</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">,</span> <span class="n">IndexWriter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience wrapper for a writer object that might fail due to locking</span>
<span class="sd">    (i.e. the ``filedb`` writer). This object will attempt once to obtain the</span>
<span class="sd">    underlying writer, and if it&#39;s successful, will simply pass method calls on</span>
<span class="sd">    to it.</span>

<span class="sd">    If this object *can&#39;t* obtain a writer immediately, it will *buffer*</span>
<span class="sd">    delete, add, and update method calls in memory until you call ``commit()``.</span>
<span class="sd">    At that point, this object will start running in a separate thread, trying</span>
<span class="sd">    to obtain the writer over and over, and once it obtains it, &quot;replay&quot; all</span>
<span class="sd">    the buffered method calls on it.</span>

<span class="sd">    In a typical scenario where you&#39;re adding a single or a few documents to</span>
<span class="sd">    the index as the result of a Web transaction, this lets you just create the</span>
<span class="sd">    writer, add, and commit, without having to worry about index locks,</span>
<span class="sd">    retries, etc.</span>

<span class="sd">    For example, to get an aynchronous writer, instead of this:</span>

<span class="sd">    &gt;&gt;&gt; writer = myindex.writer()</span>

<span class="sd">    Do this:</span>

<span class="sd">    &gt;&gt;&gt; from whoosh.writing import AsyncWriter</span>
<span class="sd">    &gt;&gt;&gt; writer = AsyncWriter(myindex)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">writerargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param index: the :class:`whoosh.index.Index` to write to.</span>
<span class="sd">        :param delay: the delay (in seconds) between attempts to instantiate</span>
<span class="sd">            the actual writer.</span>
<span class="sd">        :param writerargs: an optional dictionary specifying keyword arguments</span>
<span class="sd">            to to be passed to the index&#39;s ``writer()`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writerargs</span> <span class="o">=</span> <span class="n">writerargs</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">writerargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">LockError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writer</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="AsyncWriter.reader"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter.reader">[docs]</a>    <span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">searcher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh.searching</span> <span class="kn">import</span> <span class="n">Searcher</span>

        <span class="k">return</span> <span class="n">Searcher</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">(),</span> <span class="n">fromindex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">method</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>

<div class="viewcode-block" id="AsyncWriter.run"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span>
        <span class="k">while</span> <span class="n">writer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">writer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">writerargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">LockError</span><span class="p">:</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delay</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">commitargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">commitkwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AsyncWriter.delete_document"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter.delete_document">[docs]</a>    <span class="k">def</span> <span class="nf">delete_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record</span><span class="p">(</span><span class="s2">&quot;delete_document&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AsyncWriter.add_document"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter.add_document">[docs]</a>    <span class="k">def</span> <span class="nf">add_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record</span><span class="p">(</span><span class="s2">&quot;add_document&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AsyncWriter.update_document"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter.update_document">[docs]</a>    <span class="k">def</span> <span class="nf">update_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record</span><span class="p">(</span><span class="s2">&quot;update_document&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AsyncWriter.add_field"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter.add_field">[docs]</a>    <span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record</span><span class="p">(</span><span class="s2">&quot;add_field&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AsyncWriter.remove_field"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter.remove_field">[docs]</a>    <span class="k">def</span> <span class="nf">remove_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record</span><span class="p">(</span><span class="s2">&quot;remove_field&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AsyncWriter.delete_by_term"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter.delete_by_term">[docs]</a>    <span class="k">def</span> <span class="nf">delete_by_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record</span><span class="p">(</span><span class="s2">&quot;delete_by_term&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AsyncWriter.commit"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter.commit">[docs]</a>    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commitargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">commitkwargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span></div>

<div class="viewcode-block" id="AsyncWriter.cancel"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.AsyncWriter.cancel">[docs]</a>    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<span class="c1"># Ex post factor functions</span>


<span class="k">def</span> <span class="nf">add_spelling</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">fieldnames</span><span class="p">,</span> <span class="n">commit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds spelling files to an existing index that was created without</span>
<span class="sd">    them, and modifies the schema so the given fields have the ``spelling``</span>
<span class="sd">    attribute. Only works on filedb indexes.</span>

<span class="sd">    &gt;&gt;&gt; ix = index.open_dir(&quot;testindex&quot;)</span>
<span class="sd">    &gt;&gt;&gt; add_spelling(ix, [&quot;content&quot;, &quot;tags&quot;])</span>

<span class="sd">    :param ix: a :class:`whoosh.filedb.fileindex.FileIndex` object.</span>
<span class="sd">    :param fieldnames: a list of field names to create word graphs for.</span>
<span class="sd">    :param force: if True, overwrites existing word graph files. This is only</span>
<span class="sd">        useful for debugging.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">whoosh.automata</span> <span class="kn">import</span> <span class="n">fst</span>
    <span class="kn">from</span> <span class="nn">whoosh.reading</span> <span class="kn">import</span> <span class="n">SegmentReader</span>

    <span class="n">writer</span> <span class="o">=</span> <span class="n">ix</span><span class="o">.</span><span class="n">writer</span><span class="p">()</span>
    <span class="n">storage</span> <span class="o">=</span> <span class="n">writer</span><span class="o">.</span><span class="n">storage</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">writer</span><span class="o">.</span><span class="n">schema</span>
    <span class="n">segments</span> <span class="o">=</span> <span class="n">writer</span><span class="o">.</span><span class="n">segments</span>

    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">codec</span><span class="p">()</span><span class="o">.</span><span class="n">FST_EXT</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">SegmentReader</span><span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">segment</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">create_file</span><span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
        <span class="n">gw</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">GraphWriter</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">fieldnames</span><span class="p">:</span>
            <span class="n">gw</span><span class="o">.</span><span class="n">start_field</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">lexicon</span><span class="p">(</span><span class="n">fieldname</span><span class="p">):</span>
                <span class="n">gw</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="n">gw</span><span class="o">.</span><span class="n">finish_field</span><span class="p">()</span>
        <span class="n">gw</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">fieldnames</span><span class="p">:</span>
        <span class="n">schema</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span><span class="o">.</span><span class="n">spelling</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">commit</span><span class="p">:</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span><span class="n">merge</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="c1"># Buffered writer class</span>


<div class="viewcode-block" id="BufferedWriter"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.BufferedWriter">[docs]</a><span class="k">class</span> <span class="nc">BufferedWriter</span><span class="p">(</span><span class="n">IndexWriter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience class that acts like a writer but buffers added documents</span>
<span class="sd">    before dumping the buffered documents as a batch into the actual index.</span>

<span class="sd">    In scenarios where you are continuously adding single documents very</span>
<span class="sd">    rapidly (for example a web application where lots of users are adding</span>
<span class="sd">    content simultaneously), using a BufferedWriter is *much* faster than</span>
<span class="sd">    opening and committing a writer for each document you add. If you&#39;re adding</span>
<span class="sd">    batches of documents at a time, you can just use a regular writer.</span>

<span class="sd">    (This class may also be useful for batches of ``update_document`` calls. In</span>
<span class="sd">    a normal writer, ``update_document`` calls cannot update documents you&#39;ve</span>
<span class="sd">    added *in that writer*. With ``BufferedWriter``, this will work.)</span>

<span class="sd">    To use this class, create it from your index and *keep it open*, sharing</span>
<span class="sd">    it between threads.</span>

<span class="sd">    &gt;&gt;&gt; from whoosh.writing import BufferedWriter</span>
<span class="sd">    &gt;&gt;&gt; writer = BufferedWriter(myindex, period=120, limit=20)</span>
<span class="sd">    &gt;&gt;&gt; # Then you can use the writer to add and update documents</span>
<span class="sd">    &gt;&gt;&gt; writer.add_document(...)</span>
<span class="sd">    &gt;&gt;&gt; writer.add_document(...)</span>
<span class="sd">    &gt;&gt;&gt; writer.add_document(...)</span>
<span class="sd">    &gt;&gt;&gt; # Before the writer goes out of scope, call close() on it</span>
<span class="sd">    &gt;&gt;&gt; writer.close()</span>

<span class="sd">    .. note::</span>
<span class="sd">        This object stores documents in memory and may keep an underlying</span>
<span class="sd">        writer open, so you must explicitly call the</span>
<span class="sd">        :meth:`~BufferedWriter.close` method on this object before it goes out</span>
<span class="sd">        of scope to release the write lock and make sure any uncommitted</span>
<span class="sd">        changes are saved.</span>

<span class="sd">    You can read/search the combination of the on-disk index and the</span>
<span class="sd">    buffered documents in memory by calling ``BufferedWriter.reader()`` or</span>
<span class="sd">    ``BufferedWriter.searcher()``. This allows quasi-real-time search, where</span>
<span class="sd">    documents are available for searching as soon as they are buffered in</span>
<span class="sd">    memory, before they are committed to disk.</span>

<span class="sd">    .. tip::</span>
<span class="sd">        By using a searcher from the shared writer, multiple *threads* can</span>
<span class="sd">        search the buffered documents. Of course, other *processes* will only</span>
<span class="sd">        see the documents that have been written to disk. If you want indexed</span>
<span class="sd">        documents to become available to other processes as soon as possible,</span>
<span class="sd">        you have to use a traditional writer instead of a ``BufferedWriter``.</span>

<span class="sd">    You can control how often the ``BufferedWriter`` flushes the in-memory</span>
<span class="sd">    index to disk using the ``period`` and ``limit`` arguments. ``period`` is</span>
<span class="sd">    the maximum number of seconds between commits. ``limit`` is the maximum</span>
<span class="sd">    number of additions to buffer between commits.</span>

<span class="sd">    You don&#39;t need to call ``commit()`` on the ``BufferedWriter`` manually.</span>
<span class="sd">    Doing so will just flush the buffered documents to disk early. You can</span>
<span class="sd">    continue to make changes after calling ``commit()``, and you can call</span>
<span class="sd">    ``commit()`` multiple times.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">writerargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">commitargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param index: the :class:`whoosh.index.Index` to write to.</span>
<span class="sd">        :param period: the maximum amount of time (in seconds) between commits.</span>
<span class="sd">            Set this to ``0`` or ``None`` to not use a timer. Do not set this</span>
<span class="sd">            any lower than a few seconds.</span>
<span class="sd">        :param limit: the maximum number of documents to buffer before</span>
<span class="sd">            committing.</span>
<span class="sd">        :param writerargs: dictionary specifying keyword arguments to be passed</span>
<span class="sd">            to the index&#39;s ``writer()`` method when creating a writer.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writerargs</span> <span class="o">=</span> <span class="n">writerargs</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">commitargs</span> <span class="o">=</span> <span class="n">commitargs</span> <span class="ow">or</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">writerargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_make_ram_index</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bufferedcount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Start timer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timer</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_make_ram_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh.codec.memory</span> <span class="kn">import</span> <span class="n">MemoryCodec</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">codec</span> <span class="o">=</span> <span class="n">MemoryCodec</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_ram_reader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">codec</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">schema</span>

<div class="viewcode-block" id="BufferedWriter.reader"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.BufferedWriter.reader">[docs]</a>    <span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh.reading</span> <span class="kn">import</span> <span class="n">MultiReader</span>

        <span class="n">reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="n">ramreader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ram_reader</span><span class="p">()</span>

        <span class="c1"># If there are in-memory docs, combine the readers</span>
        <span class="k">if</span> <span class="n">ramreader</span><span class="o">.</span><span class="n">doc_count</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">reader</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">():</span>
                <span class="n">reader</span> <span class="o">=</span> <span class="n">MultiReader</span><span class="p">([</span><span class="n">reader</span><span class="p">,</span> <span class="n">ramreader</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reader</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">ramreader</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">reader</span></div>

    <span class="k">def</span> <span class="nf">searcher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh.searching</span> <span class="kn">import</span> <span class="n">Searcher</span>

        <span class="k">return</span> <span class="n">Searcher</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">(),</span> <span class="n">fromindex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span><span class="n">restart</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="BufferedWriter.commit"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.BufferedWriter.commit">[docs]</a>    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restart</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="n">ramreader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ram_reader</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_ram_index</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bufferedcount</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">ramreader</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">commitargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bufferedcount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">restart</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">writerargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">timer</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">add_reader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
        <span class="c1"># Pass through to the underlying on-disk index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<div class="viewcode-block" id="BufferedWriter.add_document"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.BufferedWriter.add_document">[docs]</a>    <span class="k">def</span> <span class="nf">add_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">fields</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="c1"># Hijack a writer to make the calls into the codec</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">codec</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                <span class="n">w</span><span class="o">.</span><span class="n">add_document</span><span class="p">(</span><span class="o">**</span><span class="n">fields</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">bufferedcount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bufferedcount</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

<div class="viewcode-block" id="BufferedWriter.update_document"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.BufferedWriter.update_document">[docs]</a>    <span class="k">def</span> <span class="nf">update_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">fields</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="n">IndexWriter</span><span class="o">.</span><span class="n">update_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">fields</span><span class="p">)</span></div>

<div class="viewcode-block" id="BufferedWriter.delete_document"><a class="viewcode-back" href="../../api/writing.html#whoosh.writing.BufferedWriter.delete_document">[docs]</a>    <span class="k">def</span> <span class="nf">delete_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docnum</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">doc_count_all</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">docnum</span> <span class="o">&lt;</span> <span class="n">base</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">delete_document</span><span class="p">(</span><span class="n">docnum</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="n">delete</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ramsegment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">codec</span><span class="o">.</span><span class="n">segment</span>
                <span class="n">ramsegment</span><span class="o">.</span><span class="n">delete_document</span><span class="p">(</span><span class="n">docnum</span> <span class="o">-</span> <span class="n">base</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="n">delete</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">is_deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docnum</span><span class="p">):</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">doc_count_all</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">docnum</span> <span class="o">&lt;</span> <span class="n">base</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">is_deleted</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ram_reader</span><span class="p">()</span><span class="o">.</span><span class="n">is_deleted</span><span class="p">(</span><span class="n">docnum</span> <span class="o">-</span> <span class="n">base</span><span class="p">)</span></div>


<span class="c1"># Backwards compatibility with old name</span>
<span class="n">BatchWriter</span> <span class="o">=</span> <span class="n">BufferedWriter</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2007-2012 Matt Chaput.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>