<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>whoosh.fields &mdash; Whoosh-Reloaded 2.7.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Whoosh-Reloaded
          </a>
              <div class="version">
                2.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../releases/index.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction to Whoosh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../schema.html">Designing a schema</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../indexing.html">How to index documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../searching.html">How to search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parsing.html">Parsing user queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../querylang.html">The default query language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dates.html">Indexing and parsing dates/times</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../query.html">Query objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../analysis.html">About analyzers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stemming.html">Stemming, variations, and accent folding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ngrams.html">Indexing and searching N-grams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../facets.html">Sorting and faceting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../highlight.html">How to create highlighted search result excerpts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../keywords.html">Query expansion and Key word extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spelling.html">“Did you mean… ?” Correcting errors in user queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fieldcaches.html">Field caches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../batch.html">Tips for speeding up batch indexing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../threads.html">Concurrency, locking, and versioning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nested.html">Indexing and searching document hierarchies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../recipes.html">Whoosh recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/api.html">Whoosh API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tech/index.html">Technical notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Whoosh-Reloaded</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">whoosh.fields</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for whoosh.fields</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2007 Matt Chaput. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1">#    1. Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#       this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#    2. Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#       notice, this list of conditions and the following disclaimer in the</span>
<span class="c1">#       documentation and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY MATT CHAPUT ``AS IS&#39;&#39; AND ANY EXPRESS OR</span>
<span class="c1"># IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="c1"># MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO</span>
<span class="c1"># EVENT SHALL MATT CHAPUT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="c1"># INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="c1"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,</span>
<span class="c1"># OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="c1"># LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="c1"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</span>
<span class="c1"># EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1"># The views and conclusions contained in the software and documentation are</span>
<span class="c1"># those of the authors and should not be interpreted as representing official</span>
<span class="c1"># policies, either expressed or implied, of Matt Chaput.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> Contains functions and classes related to fields.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">datetime</span><span class="o">,</span> <span class="nn">fnmatch</span><span class="o">,</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">struct</span><span class="o">,</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>

<span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">analysis</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">formats</span>
<span class="kn">from</span> <span class="nn">whoosh.compat</span> <span class="kn">import</span> <span class="n">with_metaclass</span>
<span class="kn">from</span> <span class="nn">whoosh.compat</span> <span class="kn">import</span> <span class="n">itervalues</span>
<span class="kn">from</span> <span class="nn">whoosh.compat</span> <span class="kn">import</span> <span class="n">bytes_type</span><span class="p">,</span> <span class="n">string_type</span><span class="p">,</span> <span class="n">text_type</span>
<span class="kn">from</span> <span class="nn">whoosh.system</span> <span class="kn">import</span> <span class="n">emptybytes</span>
<span class="kn">from</span> <span class="nn">whoosh.system</span> <span class="kn">import</span> <span class="n">pack_byte</span>
<span class="kn">from</span> <span class="nn">whoosh.util.numeric</span> <span class="kn">import</span> <span class="n">to_sortable</span><span class="p">,</span> <span class="n">from_sortable</span>
<span class="kn">from</span> <span class="nn">whoosh.util.numeric</span> <span class="kn">import</span> <span class="n">typecode_max</span><span class="p">,</span> <span class="n">NaN</span>
<span class="kn">from</span> <span class="nn">whoosh.util.text</span> <span class="kn">import</span> <span class="n">utf8encode</span><span class="p">,</span> <span class="n">utf8decode</span>
<span class="kn">from</span> <span class="nn">whoosh.util.times</span> <span class="kn">import</span> <span class="n">datetime_to_long</span><span class="p">,</span> <span class="n">long_to_datetime</span>


<span class="c1"># Exceptions</span>


<div class="viewcode-block" id="FieldConfigurationError"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldConfigurationError">[docs]</a><span class="k">class</span> <span class="nc">FieldConfigurationError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="UnknownFieldError"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.UnknownFieldError">[docs]</a><span class="k">class</span> <span class="nc">UnknownFieldError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<span class="c1"># Field Types</span>


<div class="viewcode-block" id="FieldType"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType">[docs]</a><span class="k">class</span> <span class="nc">FieldType</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a field configuration.</span>

<span class="sd">    The FieldType object supports the following attributes:</span>

<span class="sd">    * format (formats.Format): the storage format for posting blocks.</span>

<span class="sd">    * analyzer (analysis.Analyzer): the analyzer to use to turn text into</span>
<span class="sd">      terms.</span>

<span class="sd">    * scorable (boolean): whether searches against this field may be scored.</span>
<span class="sd">      This controls whether the index stores per-document field lengths for</span>
<span class="sd">      this field.</span>

<span class="sd">    * stored (boolean): whether the content of this field is stored for each</span>
<span class="sd">      document. For example, in addition to indexing the title of a document,</span>
<span class="sd">      you usually want to store the title so it can be presented as part of</span>
<span class="sd">      the search results.</span>

<span class="sd">    * unique (boolean): whether this field&#39;s value is unique to each document.</span>
<span class="sd">      For example, &#39;path&#39; or &#39;ID&#39;. IndexWriter.update_document() will use</span>
<span class="sd">      fields marked as &#39;unique&#39; to find the previous version of a document</span>
<span class="sd">      being updated.</span>

<span class="sd">    * multitoken_query is a string indicating what kind of query to use when</span>
<span class="sd">      a &quot;word&quot; in a user query parses into multiple tokens. The string is</span>
<span class="sd">      interpreted by the query parser. The strings understood by the default</span>
<span class="sd">      query parser are &quot;first&quot; (use first token only), &quot;and&quot; (join the tokens</span>
<span class="sd">      with an AND query), &quot;or&quot; (join the tokens with OR), &quot;phrase&quot; (join</span>
<span class="sd">      the tokens with a phrase query), and &quot;default&quot; (use the query parser&#39;s</span>
<span class="sd">      default join type).</span>

<span class="sd">    * vector (formats.Format or boolean): the format to use to store term</span>
<span class="sd">        vectors. If not a ``Format`` object, any true value means to use the</span>
<span class="sd">        index format as the term vector format. Any flase value means don&#39;t</span>
<span class="sd">        store term vectors for this field.</span>

<span class="sd">    The constructor for the base field type simply lets you supply your own</span>
<span class="sd">    attribute values.  Subclasses may configure some or all of this for you.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">analyzer</span> <span class="o">=</span> <span class="nb">format</span> <span class="o">=</span> <span class="n">scorable</span> <span class="o">=</span> <span class="n">stored</span> <span class="o">=</span> <span class="n">unique</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">indexed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">multitoken_query</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span>
    <span class="n">sortable_typecode</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">column_type</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">,</span>
        <span class="n">analyzer</span><span class="p">,</span>
        <span class="n">scorable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">multitoken_query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
        <span class="n">sortable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="nb">format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analyzer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scorable</span> <span class="o">=</span> <span class="n">scorable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="n">stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="n">unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multitoken_query</span> <span class="o">=</span> <span class="n">multitoken_query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sortable</span><span class="p">(</span><span class="n">sortable</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">formats</span><span class="o">.</span><span class="n">Format</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">vector</span>
        <span class="k">elif</span> <span class="n">vector</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(format=</span><span class="si">%r</span><span class="s2">, scorable=</span><span class="si">%s</span><span class="s2">, stored=</span><span class="si">%s</span><span class="s2">, unique=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scorable</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stored</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">FieldType</span><span class="p">),</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">format</span><span class="p">),</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scorable</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">scorable</span><span class="p">),</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">stored</span><span class="p">),</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">unique</span><span class="p">),</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">column_type</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="c1"># Text</span>

<div class="viewcode-block" id="FieldType.index"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an iterator of (btext, frequency, weight, encoded_value)</span>
<span class="sd">        tuples for each unique word in the input value.</span>

<span class="sd">        The default implementation uses the ``analyzer`` attribute to tokenize</span>
<span class="sd">        the value into strings, then encodes them into bytes using UTF-8.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> field </span><span class="si">%r</span><span class="s2"> cannot index without a format&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> is not unicode or sequence&quot;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">formats</span><span class="o">.</span><span class="n">Format</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;index&quot;</span>

        <span class="n">word_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">word_values</span>
        <span class="n">ana</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span>
        <span class="k">for</span> <span class="n">tstring</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">wt</span><span class="p">,</span> <span class="n">vbytes</span> <span class="ow">in</span> <span class="n">word_values</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ana</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">utf8encode</span><span class="p">(</span><span class="n">tstring</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq</span><span class="p">,</span> <span class="n">wt</span><span class="p">,</span> <span class="n">vbytes</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldType.tokenize"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyzes the given string and returns an iterator of Token objects</span>
<span class="sd">        (note: for performance reasons, actually the same token yielded over</span>
<span class="sd">        and over with different attributes).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> field has no analyzer&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldType.process_text"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.process_text">[docs]</a>    <span class="k">def</span> <span class="nf">process_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyzes the given string and returns an iterator of token texts.</span>

<span class="sd">        &gt;&gt;&gt; field = fields.TEXT()</span>
<span class="sd">        &gt;&gt;&gt; list(field.process_text(&quot;The ides of March&quot;))</span>
<span class="sd">        [&quot;ides&quot;, &quot;march&quot;]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> field has no format&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">qstring</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

    <span class="c1"># Conversion</span>

<div class="viewcode-block" id="FieldType.to_bytes"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.to_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a bytes representation of the given value, appropriate to be</span>
<span class="sd">        written to disk. The default implementation assumes a unicode value and</span>
<span class="sd">        encodes it using UTF-8.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">bytes_type</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">utf8encode</span><span class="p">(</span><span class="n">value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="FieldType.to_column_value"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.to_column_value">[docs]</a>    <span class="k">def</span> <span class="nf">to_column_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an object suitable to be inserted into the document values</span>
<span class="sd">        column for this field. The default implementation simply calls</span>
<span class="sd">        ``self.to_bytes(value)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">from_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utf8decode</span><span class="p">(</span><span class="n">bs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">from_column_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="c1"># Columns/sorting</span>

    <span class="k">def</span> <span class="nf">set_sortable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sortable</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sortable</span><span class="p">,</span> <span class="n">columns</span><span class="o">.</span><span class="n">Column</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="n">sortable</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_column</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="FieldType.sortable_terms"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.sortable_terms">[docs]</a>    <span class="k">def</span> <span class="nf">sortable_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ixreader</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator of the &quot;sortable&quot; tokens in the given reader and</span>
<span class="sd">        field. These values can be used for sorting. The default implementation</span>
<span class="sd">        simply returns all tokens in the field.</span>

<span class="sd">        This can be overridden by field types such as NUMERIC where some values</span>
<span class="sd">        in a field are not useful for sorting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">ixreader</span><span class="o">.</span><span class="n">lexicon</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">default_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">columns</span><span class="o">.</span><span class="n">VarBytesColumn</span><span class="p">()</span>

    <span class="c1"># Parsing</span>

<div class="viewcode-block" id="FieldType.self_parsing"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.self_parsing">[docs]</a>    <span class="k">def</span> <span class="nf">self_parsing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subclasses should override this method to return True if they want</span>
<span class="sd">        the query parser to call the field&#39;s ``parse_query()`` method instead</span>
<span class="sd">        of running the analyzer on text in this field. This is useful where</span>
<span class="sd">        the field needs full control over how queries are interpreted, such</span>
<span class="sd">        as in the numeric field type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="FieldType.parse_query"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.parse_query">[docs]</a>    <span class="k">def</span> <span class="nf">parse_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When ``self_parsing()`` returns True, the query parser will call</span>
<span class="sd">        this method to parse basic query text.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldType.parse_range"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.parse_range">[docs]</a>    <span class="k">def</span> <span class="nf">parse_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">startexcl</span><span class="p">,</span> <span class="n">endexcl</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When ``self_parsing()`` returns True, the query parser will call</span>
<span class="sd">        this method to parse range query text. If this method returns None</span>
<span class="sd">        instead of a query object, the parser will fall back to parsing the</span>
<span class="sd">        start and end terms using process_text().</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="c1"># Spelling</span>

<div class="viewcode-block" id="FieldType.separate_spelling"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.separate_spelling">[docs]</a>    <span class="k">def</span> <span class="nf">separate_spelling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the field stores unstemmed words in a separate field for</span>
<span class="sd">        spelling suggestions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="FieldType.spelling_fieldname"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.spelling_fieldname">[docs]</a>    <span class="k">def</span> <span class="nf">spelling_fieldname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of a field to use for spelling suggestions instead of</span>
<span class="sd">        this field.</span>

<span class="sd">        :param fieldname: the name of this field.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">fieldname</span></div>

<div class="viewcode-block" id="FieldType.spellable_words"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.spellable_words">[docs]</a>    <span class="k">def</span> <span class="nf">spellable_words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an iterator of each unique word (in sorted order) in the</span>
<span class="sd">        input value, suitable for inclusion in the field&#39;s word graph.</span>

<span class="sd">        The default behavior is to call the field analyzer with the keyword</span>
<span class="sd">        argument ``no_morph=True``, which should make the analyzer skip any</span>
<span class="sd">        morphological transformation filters (e.g. stemming) to preserve the</span>
<span class="sd">        original form of the words. Exotic field types may need to override</span>
<span class="sd">        this behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">words</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">no_morph</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">words</span><span class="p">)))</span></div>

    <span class="c1"># Utility</span>

<div class="viewcode-block" id="FieldType.subfields"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.subfields">[docs]</a>    <span class="k">def</span> <span class="nf">subfields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator of ``(name_prefix, fieldobject)`` pairs for the</span>
<span class="sd">        fields that need to be indexed when content is put in this field. The</span>
<span class="sd">        default implementation simply yields ``(&quot;&quot;, self)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">yield</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="FieldType.supports"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.supports">[docs]</a>    <span class="k">def</span> <span class="nf">supports</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the underlying format supports the given posting</span>
<span class="sd">        value type.</span>

<span class="sd">        &gt;&gt;&gt; field = TEXT()</span>
<span class="sd">        &gt;&gt;&gt; field.supports(&quot;positions&quot;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; field.supports(&quot;chars&quot;)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">supports</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldType.clean"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.FieldType.clean">[docs]</a>    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears any cached information in the field and any child objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="s2">&quot;clean&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span></div>

    <span class="c1"># Events</span>

    <span class="k">def</span> <span class="nf">on_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">on_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">pass</span></div>


<span class="c1"># Wrapper base class</span>


<span class="k">class</span> <span class="nc">FieldWrapper</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subfield</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subfield</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">subfield</span> <span class="o">=</span> <span class="n">subfield</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span> <span class="o">=</span> <span class="n">subfield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_prefix</span> <span class="o">=</span> <span class="n">prefix</span>

        <span class="c1"># By default we&#39;ll copy all the subfield&#39;s attributes -- override these</span>
        <span class="c1"># in subclass constructor for things you want to change</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">subfield</span><span class="o">.</span><span class="n">analyzer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">subfield</span><span class="o">.</span><span class="n">format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="n">subfield</span><span class="o">.</span><span class="n">column_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scorable</span> <span class="o">=</span> <span class="n">subfield</span><span class="o">.</span><span class="n">scorable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="n">subfield</span><span class="o">.</span><span class="n">stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="n">subfield</span><span class="o">.</span><span class="n">unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span> <span class="o">=</span> <span class="n">subfield</span><span class="o">.</span><span class="n">indexed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">subfield</span><span class="o">.</span><span class="n">vector</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># Text</span>

    <span class="c1"># def index(self, value, boost=1.0, **kwargs):</span>
    <span class="c1">#     return self.subfield.index(value, boost, **kwargs)</span>
    <span class="c1">#</span>
    <span class="c1"># def tokenize(self, value, **kwargs):</span>
    <span class="c1">#     return self.subfield.tokenize(value, **kwargs)</span>
    <span class="c1">#</span>
    <span class="c1"># def process_text(self, qstring, mode=&#39;&#39;, **kwargs):</span>
    <span class="c1">#     return self.subfield.process_text(qstring, mode, **kwargs)</span>

    <span class="c1"># Conversion</span>

    <span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_column_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">to_column_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_column_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">from_column_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="c1"># Sorting/columns</span>

    <span class="k">def</span> <span class="nf">set_sortable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">set_sortable</span><span class="p">(</span><span class="n">sortable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sortable_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ixreader</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">sortable_terms</span><span class="p">(</span><span class="n">ixreader</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">default_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">default_column</span><span class="p">()</span>

    <span class="c1"># Parsing</span>

    <span class="k">def</span> <span class="nf">self_parsing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">self_parsing</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parse_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">parse_query</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">boost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">startexcl</span><span class="p">,</span> <span class="n">endexcl</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">parse_range</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">startexcl</span><span class="p">,</span> <span class="n">endexcl</span><span class="p">,</span> <span class="n">boost</span><span class="p">)</span>

    <span class="c1"># Utility</span>

    <span class="k">def</span> <span class="nf">subfields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The default FieldWrapper.subfields() implementation DOES NOT split</span>
        <span class="c1"># out the subfield here -- you need to override if that&#39;s what you want</span>
        <span class="k">yield</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">supports</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">supports</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

    <span class="c1"># Events</span>

    <span class="k">def</span> <span class="nf">on_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">on_add</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span><span class="o">.</span><span class="n">on_remove</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span>


<span class="c1"># Pre-configured field types</span>


<div class="viewcode-block" id="ID"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.ID">[docs]</a><span class="k">class</span> <span class="nc">ID</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configured field type that indexes the entire value of the field as one</span>
<span class="sd">    token. This is useful for data you don&#39;t want to tokenize, such as the path</span>
<span class="sd">    of a file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">field_boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sortable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">analyzer</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param stored: Whether the value of this field is stored with the</span>
<span class="sd">            document.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analyzer</span> <span class="ow">or</span> <span class="n">analysis</span><span class="o">.</span><span class="n">IDAnalyzer</span><span class="p">()</span>
        <span class="c1"># Don&#39;t store any information other than the doc ID</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Existence</span><span class="p">(</span><span class="n">field_boost</span><span class="o">=</span><span class="n">field_boost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="n">stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="n">unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sortable</span><span class="p">(</span><span class="n">sortable</span><span class="p">)</span></div>


<div class="viewcode-block" id="IDLIST"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.IDLIST">[docs]</a><span class="k">class</span> <span class="nc">IDLIST</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configured field type for fields containing IDs separated by whitespace</span>
<span class="sd">    and/or punctuation (or anything else, using the expression param).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">expression</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">field_boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param stored: Whether the value of this field is stored with the</span>
<span class="sd">            document.</span>
<span class="sd">        :param unique: Whether the value of this field is unique per-document.</span>
<span class="sd">        :param expression: The regular expression object to use to extract</span>
<span class="sd">            tokens. The default expression breaks tokens on CRs, LFs, tabs,</span>
<span class="sd">            spaces, commas, and semicolons.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span> <span class="ow">or</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^\r\n\t ,;]+&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">RegexAnalyzer</span><span class="p">(</span><span class="n">expression</span><span class="o">=</span><span class="n">expression</span><span class="p">)</span>
        <span class="c1"># Don&#39;t store any information other than the doc ID</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Existence</span><span class="p">(</span><span class="n">field_boost</span><span class="o">=</span><span class="n">field_boost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="n">stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="n">unique</span></div>


<div class="viewcode-block" id="NUMERIC"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.NUMERIC">[docs]</a><span class="k">class</span> <span class="nc">NUMERIC</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Special field type that lets you index integer or floating point</span>
<span class="sd">    numbers in relatively short fixed-width terms. The field converts numbers</span>
<span class="sd">    to sortable bytes for you before indexing.</span>

<span class="sd">    You specify the numeric type of the field (``int`` or ``float``) when you</span>
<span class="sd">    create the ``NUMERIC`` object. The default is ``int``. For ``int``, you can</span>
<span class="sd">    specify a size in bits (``32`` or ``64``). For both ``int`` and ``float``</span>
<span class="sd">    you can specify a ``signed`` keyword argument (default is ``True``).</span>

<span class="sd">    &gt;&gt;&gt; schema = Schema(path=STORED, position=NUMERIC(int, 64, signed=False))</span>
<span class="sd">    &gt;&gt;&gt; ix = storage.create_index(schema)</span>
<span class="sd">    &gt;&gt;&gt; with ix.writer() as w:</span>
<span class="sd">    ...     w.add_document(path=&quot;/a&quot;, position=5820402204)</span>
<span class="sd">    ...</span>

<span class="sd">    You can also use the NUMERIC field to store Decimal instances by specifying</span>
<span class="sd">    a type of ``int`` or ``long`` and the ``decimal_places`` keyword argument.</span>
<span class="sd">    This simply multiplies each number by ``(10 ** decimal_places)`` before</span>
<span class="sd">    storing it as an integer. Of course this may throw away decimal prcesision</span>
<span class="sd">    (by truncating, not rounding) and imposes the same maximum value limits as</span>
<span class="sd">    ``int``/``long``, but these may be acceptable for certain applications.</span>

<span class="sd">    &gt;&gt;&gt; from decimal import Decimal</span>
<span class="sd">    &gt;&gt;&gt; schema = Schema(path=STORED, position=NUMERIC(int, decimal_places=4))</span>
<span class="sd">    &gt;&gt;&gt; ix = storage.create_index(schema)</span>
<span class="sd">    &gt;&gt;&gt; with ix.writer() as w:</span>
<span class="sd">    ...     w.add_document(path=&quot;/a&quot;, position=Decimal(&quot;123.45&quot;)</span>
<span class="sd">    ...</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">numtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">bits</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
        <span class="n">stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">field_boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">decimal_places</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">shift_step</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">sortable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param numtype: the type of numbers that can be stored in this field,</span>
<span class="sd">            either ``int``, ``float``. If you use ``Decimal``,</span>
<span class="sd">            use the ``decimal_places`` argument to control how many decimal</span>
<span class="sd">            places the field will store.</span>
<span class="sd">        :param bits: When ``numtype`` is ``int``, the number of bits to use to</span>
<span class="sd">            store the number: 8, 16, 32, or 64.</span>
<span class="sd">        :param stored: Whether the value of this field is stored with the</span>
<span class="sd">            document.</span>
<span class="sd">        :param unique: Whether the value of this field is unique per-document.</span>
<span class="sd">        :param decimal_places: specifies the number of decimal places to save</span>
<span class="sd">            when storing Decimal instances. If you set this, you will always</span>
<span class="sd">            get Decimal instances back from the field.</span>
<span class="sd">        :param shift_steps: The number of bits of precision to shift away at</span>
<span class="sd">            each tiered indexing level. Values should generally be 1-8. Lower</span>
<span class="sd">            values yield faster searches but take up more space. A value</span>
<span class="sd">            of `0` means no tiered indexing.</span>
<span class="sd">        :param signed: Whether the numbers stored in this field may be</span>
<span class="sd">            negative.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Allow users to specify strings instead of Python types in case</span>
        <span class="c1"># docstring isn&#39;t clear</span>
        <span class="k">if</span> <span class="n">numtype</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
            <span class="n">numtype</span> <span class="o">=</span> <span class="nb">int</span>
        <span class="k">if</span> <span class="n">numtype</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span><span class="p">:</span>
            <span class="n">numtype</span> <span class="o">=</span> <span class="nb">float</span>
        <span class="c1"># Raise an error if the user tries to use a type other than int or</span>
        <span class="c1"># float</span>
        <span class="k">if</span> <span class="n">numtype</span> <span class="ow">is</span> <span class="n">Decimal</span><span class="p">:</span>
            <span class="n">numtype</span> <span class="o">=</span> <span class="nb">int</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">decimal_places</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;To store Decimal instances, you must set the &quot;</span>
                    <span class="s2">&quot;decimal_places argument&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">numtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t use </span><span class="si">%r</span><span class="s2"> as a type, use int or float&quot;</span> <span class="o">%</span> <span class="n">numtype</span><span class="p">)</span>
        <span class="c1"># Sanity check</span>
        <span class="k">if</span> <span class="n">numtype</span> <span class="ow">is</span> <span class="nb">float</span> <span class="ow">and</span> <span class="n">decimal_places</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;A float type and decimal_places argument </span><span class="si">%r</span><span class="s2"> are &quot;</span>
                <span class="s2">&quot;incompatible&quot;</span> <span class="o">%</span> <span class="n">decimal_places</span>
            <span class="p">)</span>

        <span class="n">intsizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">]</span>
        <span class="n">intcodes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;Q&quot;</span><span class="p">]</span>
        <span class="c1"># Set up field configuration based on type and size</span>
        <span class="k">if</span> <span class="n">numtype</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
            <span class="n">bits</span> <span class="o">=</span> <span class="mi">64</span>  <span class="c1"># Floats are converted to 64 bit ints</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bits</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">intsizes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid bits </span><span class="si">%r</span><span class="s2">, use 8, 16, 32, or 64&quot;</span> <span class="o">%</span> <span class="n">bits</span><span class="p">)</span>
        <span class="c1"># Type code for the *sortable* representation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortable_typecode</span> <span class="o">=</span> <span class="n">intcodes</span><span class="p">[</span><span class="n">intsizes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bits</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_struct</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sortable_typecode</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">numtype</span> <span class="o">=</span> <span class="n">numtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="n">stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="n">unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span> <span class="o">=</span> <span class="n">decimal_places</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_step</span> <span class="o">=</span> <span class="n">shift_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signed</span> <span class="o">=</span> <span class="n">signed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">IDAnalyzer</span><span class="p">()</span>
        <span class="c1"># Don&#39;t store any information other than the doc ID</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Existence</span><span class="p">(</span><span class="n">field_boost</span><span class="o">=</span><span class="n">field_boost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_max</span><span class="p">()</span>

        <span class="c1"># Column configuration</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">numtype</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">default</span> <span class="o">=</span> <span class="n">typecode_max</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sortable_typecode</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">default</span> <span class="o">=</span> <span class="n">NaN</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">default</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;The default </span><span class="si">%r</span><span class="s2"> is not a valid number for this &quot;</span> <span class="s2">&quot;field&quot;</span> <span class="o">%</span> <span class="n">default</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sortable</span><span class="p">(</span><span class="n">sortable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;_struct&quot;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;_struct&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_struct</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sortable_typecode</span><span class="p">))</span>
        <span class="k">if</span> <span class="s2">&quot;min_value&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;min_value&quot;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;max_value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_max</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_min_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">numtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numtype</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bits</span>
        <span class="n">signed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signed</span>

        <span class="c1"># Calculate the minimum and maximum possible values for error checking</span>
        <span class="n">min_value</span> <span class="o">=</span> <span class="n">from_sortable</span><span class="p">(</span><span class="n">numtype</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">signed</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="n">from_sortable</span><span class="p">(</span><span class="n">numtype</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">signed</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span>

    <span class="k">def</span> <span class="nf">default_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">columns</span><span class="o">.</span><span class="n">NumericColumn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sortable_typecode</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># If the user gave us a list of numbers, recurse on the list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">num</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">item</span>
            <span class="k">return</span>

        <span class="c1"># word, freq, weight, valuestring</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_step</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_step</span><span class="p">):</span>
                <span class="k">yield</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">shift</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">emptybytes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">emptybytes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepare_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">emptybytes</span> <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span>
        <span class="k">if</span> <span class="n">dc</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">string_type</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">)):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">dc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t index a Decimal object unless you specified &quot;</span>
                <span class="s2">&quot;decimal_places on the field&quot;</span>
            <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value </span><span class="si">%r</span><span class="s2"> overflowed number type </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numtype</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_value</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_value</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Numeric field value </span><span class="si">%s</span><span class="s2"> out of range [</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">]&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_value</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">unprepare_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span>
        <span class="k">if</span> <span class="n">dc</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="n">dc</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="n">dc</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">to_column_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">array</span><span class="p">)):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_number</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_sortable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">signed</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_column_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">from_sortable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">signed</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unprepare_number</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># Try to avoid re-encoding; this sucks because on Python 2 we can&#39;t</span>
        <span class="c1"># tell the difference between a string and encoded bytes, so we have</span>
        <span class="c1"># to require the user use unicode when they mean string</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bytes_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">emptybytes</span> <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortable_to_bytes</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_number</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">to_sortable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">signed</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortable_to_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sortable_to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">shift</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span>
        <span class="k">return</span> <span class="n">pack_byte</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bs</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">bs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">from_sortable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">signed</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unprepare_number</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">process_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">text</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">self_parsing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parse_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">query</span>
        <span class="kn">from</span> <span class="nn">whoosh.qparser.common</span> <span class="kn">import</span> <span class="n">QueryParserError</span>

        <span class="k">if</span> <span class="n">qstring</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">Every</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">qstring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QueryParserError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> is not a valid number&quot;</span> <span class="o">%</span> <span class="n">qstring</span><span class="p">)</span>

        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">startexcl</span><span class="p">,</span> <span class="n">endexcl</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">query</span>
        <span class="kn">from</span> <span class="nn">whoosh.qparser.common</span> <span class="kn">import</span> <span class="n">QueryParserError</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">QueryParserError</span><span class="p">(</span><span class="s2">&quot;Range start </span><span class="si">%r</span><span class="s2"> is not a valid number&quot;</span> <span class="o">%</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_number</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">end</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">QueryParserError</span><span class="p">(</span><span class="s2">&quot;Range end </span><span class="si">%r</span><span class="s2"> is not a valid number&quot;</span> <span class="o">%</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_number</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">NumericRange</span><span class="p">(</span>
            <span class="n">fieldname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">startexcl</span><span class="p">,</span> <span class="n">endexcl</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">sortable_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ixreader</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\x00</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">ixreader</span><span class="o">.</span><span class="n">lexicon</span><span class="p">(</span><span class="n">fieldname</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">zero</span><span class="p">:</span>
                <span class="c1"># Only yield the full-precision values</span>
                <span class="k">break</span>
            <span class="k">yield</span> <span class="n">token</span></div>


<div class="viewcode-block" id="DATETIME"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.DATETIME">[docs]</a><span class="k">class</span> <span class="nc">DATETIME</span><span class="p">(</span><span class="n">NUMERIC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Special field type that lets you index datetime objects. The field</span>
<span class="sd">    converts the datetime objects to sortable text for you before indexing.</span>

<span class="sd">    Since this field is based on Python&#39;s datetime module it shares all the</span>
<span class="sd">    limitations of that module, such as the inability to represent dates before</span>
<span class="sd">    year 1 in the proleptic Gregorian calendar. However, since this field</span>
<span class="sd">    stores datetimes as an integer number of microseconds, it could easily</span>
<span class="sd">    represent a much wider range of dates if the Python datetime implementation</span>
<span class="sd">    ever supports them.</span>

<span class="sd">    &gt;&gt;&gt; schema = Schema(path=STORED, date=DATETIME)</span>
<span class="sd">    &gt;&gt;&gt; ix = storage.create_index(schema)</span>
<span class="sd">    &gt;&gt;&gt; w = ix.writer()</span>
<span class="sd">    &gt;&gt;&gt; w.add_document(path=&quot;/a&quot;, date=datetime.now())</span>
<span class="sd">    &gt;&gt;&gt; w.commit()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sortable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param stored: Whether the value of this field is stored with the</span>
<span class="sd">            document.</span>
<span class="sd">        :param unique: Whether the value of this field is unique per-document.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">DATETIME</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="nb">int</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">stored</span><span class="o">=</span><span class="n">stored</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span> <span class="n">shift_step</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">sortable</span><span class="o">=</span><span class="n">sortable</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepare_datetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh.util.times</span> <span class="kn">import</span> <span class="n">floor</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">text_type</span><span class="p">):</span>
            <span class="c1"># For indexing, support same strings as for query parsing --</span>
            <span class="c1"># convert unicode to datetime object</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_datestring</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># this makes most sense (unspecified = lowest)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">datetime_to_long</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bytes_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> is not a datetime&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">to_column_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bytes_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> is not a datetime&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_datetime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_column_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">long_to_datetime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_datetime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">NUMERIC</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bs</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">NUMERIC</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">long_to_datetime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_datestring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qstring</span><span class="p">):</span>
        <span class="c1"># This method parses a very simple datetime representation of the form</span>
        <span class="c1"># YYYY[MM[DD[hh[mm[ss[uuuuuu]]]]]]</span>
        <span class="kn">from</span> <span class="nn">whoosh.util.times</span> <span class="kn">import</span> <span class="n">adatetime</span><span class="p">,</span> <span class="n">fix</span><span class="p">,</span> <span class="n">is_void</span>

        <span class="n">qstring</span> <span class="o">=</span> <span class="n">qstring</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">month</span> <span class="o">=</span> <span class="n">day</span> <span class="o">=</span> <span class="n">hour</span> <span class="o">=</span> <span class="n">minute</span> <span class="o">=</span> <span class="n">second</span> <span class="o">=</span> <span class="n">microsecond</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qstring</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">month</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qstring</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">day</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qstring</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">hour</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qstring</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">:</span>
            <span class="n">minute</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qstring</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">14</span><span class="p">:</span>
            <span class="n">second</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qstring</span><span class="p">[</span><span class="mi">12</span><span class="p">:</span><span class="mi">14</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">:</span>
            <span class="n">microsecond</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qstring</span><span class="p">[</span><span class="mi">14</span><span class="p">:])</span>

        <span class="n">at</span> <span class="o">=</span> <span class="n">fix</span><span class="p">(</span><span class="n">adatetime</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">hour</span><span class="p">,</span> <span class="n">minute</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">microsecond</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">is_void</span><span class="p">(</span><span class="n">at</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> is not a parseable date&quot;</span> <span class="o">%</span> <span class="n">qstring</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">at</span>

    <span class="k">def</span> <span class="nf">parse_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">query</span>
        <span class="kn">from</span> <span class="nn">whoosh.util.times</span> <span class="kn">import</span> <span class="n">is_ambiguous</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_datestring</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">error_query</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_ambiguous</span><span class="p">(</span><span class="n">at</span><span class="p">):</span>
            <span class="n">startnum</span> <span class="o">=</span> <span class="n">datetime_to_long</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">floor</span><span class="p">())</span>
            <span class="n">endnum</span> <span class="o">=</span> <span class="n">datetime_to_long</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">ceil</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">NumericRange</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">startnum</span><span class="p">,</span> <span class="n">endnum</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">startexcl</span><span class="p">,</span> <span class="n">endexcl</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">query</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">Every</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">startdt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_datestring</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">()</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">datetime_to_long</span><span class="p">(</span><span class="n">startdt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">enddt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_datestring</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">ceil</span><span class="p">()</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">datetime_to_long</span><span class="p">(</span><span class="n">enddt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">NumericRange</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">)</span></div>


<div class="viewcode-block" id="BOOLEAN"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.BOOLEAN">[docs]</a><span class="k">class</span> <span class="nc">BOOLEAN</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Special field type that lets you index boolean values (True and False).</span>
<span class="sd">    The field converts the boolean values to text for you before indexing.</span>

<span class="sd">    &gt;&gt;&gt; schema = Schema(path=STORED, done=BOOLEAN)</span>
<span class="sd">    &gt;&gt;&gt; ix = storage.create_index(schema)</span>
<span class="sd">    &gt;&gt;&gt; w = ix.writer()</span>
<span class="sd">    &gt;&gt;&gt; w.add_document(path=&quot;/a&quot;, done=False)</span>
<span class="sd">    &gt;&gt;&gt; w.commit()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bytestrings</span> <span class="o">=</span> <span class="p">(</span><span class="sa">b</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
    <span class="n">trues</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="s2">&quot;t true yes 1&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">falses</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="s2">&quot;f false no 0&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">field_boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param stored: Whether the value of this field is stored with the</span>
<span class="sd">            document.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="n">stored</span>
        <span class="c1"># Don&#39;t store any information other than the doc ID</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Existence</span><span class="p">(</span><span class="n">field_boost</span><span class="o">=</span><span class="n">field_boost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_obj_to_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># We special case strings such as &quot;true&quot;, &quot;false&quot;, &quot;yes&quot;, &quot;no&quot;, but</span>
        <span class="c1"># otherwise call bool() on the query value. This lets you pass objects</span>
        <span class="c1"># as query values and do the right thing.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">string_type</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trues</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">string_type</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">falses</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bytes_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">string_type</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trues</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bytestrings</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">bs</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">string_type</span><span class="p">):</span>
            <span class="n">bit</span> <span class="o">=</span> <span class="n">bit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trues</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bit</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">bit</span><span class="p">)</span>
        <span class="c1"># word, freq, weight, valuestring</span>
        <span class="k">return</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">bytestrings</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">bit</span><span class="p">)],</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">emptybytes</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">self_parsing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parse_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">query</span>

        <span class="k">if</span> <span class="n">qstring</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">Every</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_to_bool</span><span class="p">(</span><span class="n">qstring</span><span class="p">),</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">)</span></div>


<div class="viewcode-block" id="STORED"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.STORED">[docs]</a><span class="k">class</span> <span class="nc">STORED</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configured field type for fields you want to store but not index.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">indexed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">stored</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>


<span class="k">class</span> <span class="nc">COLUMN</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configured field type for fields you want to store as a per-document</span>
<span class="sd">    value column but not index.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">indexed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">stored</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnobj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">columnobj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columnobj</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">VarBytesColumn</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columnobj</span><span class="p">,</span> <span class="n">columns</span><span class="o">.</span><span class="n">Column</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> is not a column object&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">columnobj</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="n">columnobj</span>

    <span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">from_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">b</span>


<div class="viewcode-block" id="KEYWORD"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.KEYWORD">[docs]</a><span class="k">class</span> <span class="nc">KEYWORD</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configured field type for fields containing space-separated or</span>
<span class="sd">    comma-separated keyword-like data (such as tags). The default is to not</span>
<span class="sd">    store positional information (so phrase searching is not allowed in this</span>
<span class="sd">    field) and to not make the field scorable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lowercase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">commas</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">scorable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">field_boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">sortable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">analyzer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param stored: Whether to store the value of the field with the</span>
<span class="sd">            document.</span>
<span class="sd">        :param commas: Whether this is a comma-separated field. If this is False</span>
<span class="sd">            (the default), it is treated as a space-separated field.</span>
<span class="sd">        :param scorable: Whether this field is scorable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">analyzer</span><span class="p">:</span>
            <span class="n">analyzer</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">KeywordAnalyzer</span><span class="p">(</span><span class="n">lowercase</span><span class="o">=</span><span class="n">lowercase</span><span class="p">,</span> <span class="n">commas</span><span class="o">=</span><span class="n">commas</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analyzer</span>

        <span class="c1"># Store field lengths and weights along with doc ID</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Frequency</span><span class="p">(</span><span class="n">field_boost</span><span class="o">=</span><span class="n">field_boost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scorable</span> <span class="o">=</span> <span class="n">scorable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="n">stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="n">unique</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">formats</span><span class="o">.</span><span class="n">Format</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">vector</span>
        <span class="k">elif</span> <span class="n">vector</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">sortable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_column</span><span class="p">()</span></div>


<div class="viewcode-block" id="TEXT"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.TEXT">[docs]</a><span class="k">class</span> <span class="nc">TEXT</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configured field type for text fields (for example, the body text of an</span>
<span class="sd">    article). The default is to store positional information to allow phrase</span>
<span class="sd">    searching. This field type is always scorable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">analyzer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">phrase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">chars</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">field_boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">multitoken_query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
        <span class="n">spelling</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sortable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lang</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">spelling_prefix</span><span class="o">=</span><span class="s2">&quot;spell_&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param analyzer: The analysis.Analyzer to use to index the field</span>
<span class="sd">            contents. See the analysis module for more information. If you omit</span>
<span class="sd">            this argument, the field uses analysis.StandardAnalyzer.</span>
<span class="sd">        :param phrase: Whether the store positional information to allow phrase</span>
<span class="sd">            searching.</span>
<span class="sd">        :param chars: Whether to store character ranges along with positions.</span>
<span class="sd">            If this is True, &quot;phrase&quot; is also implied.</span>
<span class="sd">        :param stored: Whether to store the value of this field with the</span>
<span class="sd">            document. Since this field type generally contains a lot of text,</span>
<span class="sd">            you should avoid storing it with the document unless you need to,</span>
<span class="sd">            for example to allow fast excerpts in the search results.</span>
<span class="sd">        :param spelling: if True, and if the field&#39;s analyzer changes the form</span>
<span class="sd">            of term text (such as a stemming analyzer), this field will store</span>
<span class="sd">            extra information in a separate field (named using the</span>
<span class="sd">            ``spelling_prefix`` keyword argument) to allow spelling suggestions</span>
<span class="sd">            to use the unchanged word forms as spelling suggestions.</span>
<span class="sd">        :param sortable: If True, make this field sortable using the default</span>
<span class="sd">            column type. If you pass a :class:`whoosh.columns.Column` instance</span>
<span class="sd">            instead of True, the field will use the given column type.</span>
<span class="sd">        :param lang: automaticaly configure a</span>
<span class="sd">            :class:`whoosh.analysis.LanguageAnalyzer` for the given language.</span>
<span class="sd">            This is ignored if you also specify an ``analyzer``.</span>
<span class="sd">        :param vector: if this value evaluates to true, store a list of the</span>
<span class="sd">            terms in this field in each document. If the value is an instance</span>
<span class="sd">            of :class:`whoosh.formats.Format`, the index will use the object to</span>
<span class="sd">            store the term vector. Any other true value (e.g. ``vector=True``)</span>
<span class="sd">            will use the field&#39;s index format to store the term vector as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">analyzer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analyzer</span>
        <span class="k">elif</span> <span class="n">lang</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">LanguageAnalyzer</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">StandardAnalyzer</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">chars</span><span class="p">:</span>
            <span class="n">formatclass</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Characters</span>
        <span class="k">elif</span> <span class="n">phrase</span><span class="p">:</span>
            <span class="n">formatclass</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Positions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">formatclass</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">formatclass</span><span class="p">(</span><span class="n">field_boost</span><span class="o">=</span><span class="n">field_boost</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sortable</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sortable</span><span class="p">,</span> <span class="n">columns</span><span class="o">.</span><span class="n">Column</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="n">sortable</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">VarBytesColumn</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spelling</span> <span class="o">=</span> <span class="n">spelling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spelling_prefix</span> <span class="o">=</span> <span class="n">spelling_prefix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multitoken_query</span> <span class="o">=</span> <span class="n">multitoken_query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scorable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="n">stored</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">formats</span><span class="o">.</span><span class="n">Format</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">vector</span>
        <span class="k">elif</span> <span class="n">vector</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">subfields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span>

        <span class="c1"># If the user indicated this is a spellable field, and the analyzer</span>
        <span class="c1"># is morphic, then also index into a spelling-only field that stores</span>
        <span class="c1"># minimal information</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_spelling</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">spelling_prefix</span><span class="p">,</span> <span class="n">SpellField</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">separate_spelling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spelling</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">has_morph</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">spelling_fieldname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_spelling</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spelling_prefix</span> <span class="o">+</span> <span class="n">fieldname</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fieldname</span></div>


<span class="k">class</span> <span class="nc">SpellField</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a utility field type meant to be returned by ``TEXT.subfields()``</span>
<span class="sd">    when it needs a minimal field to store the spellable words.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analyzer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Frequency</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analyzer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scorabe</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spelling</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># All the text analysis methods add &quot;nomorph&quot; to the keywords to get</span>
    <span class="c1"># unmorphed term texts</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nomorph&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">FieldType</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tokenzie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nomorph&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">FieldType</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nomorph&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">FieldType</span><span class="o">.</span><span class="n">process_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="NGRAM"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.NGRAM">[docs]</a><span class="k">class</span> <span class="nc">NGRAM</span><span class="p">(</span><span class="n">FieldType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configured field that indexes text as N-grams. For example, with a field</span>
<span class="sd">    type NGRAM(3,4), the value &quot;hello&quot; will be indexed as tokens</span>
<span class="sd">    &quot;hel&quot;, &quot;hell&quot;, &quot;ell&quot;, &quot;ello&quot;, &quot;llo&quot;. This field type chops the entire text</span>
<span class="sd">    into N-grams, including whitespace and punctuation. See :class:`NGRAMWORDS`</span>
<span class="sd">    for a field type that breaks the text into words first before chopping the</span>
<span class="sd">    words into N-grams.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">scorable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">minsize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">maxsize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">field_boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">queryor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">phrase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sortable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param minsize: The minimum length of the N-grams.</span>
<span class="sd">        :param maxsize: The maximum length of the N-grams.</span>
<span class="sd">        :param stored: Whether to store the value of this field with the</span>
<span class="sd">            document. Since this field type generally contains a lot of text,</span>
<span class="sd">            you should avoid storing it with the document unless you need to,</span>
<span class="sd">            for example to allow fast excerpts in the search results.</span>
<span class="sd">        :param queryor: if True, combine the N-grams with an Or query. The</span>
<span class="sd">            default is to combine N-grams with an And query.</span>
<span class="sd">        :param phrase: store positions on the N-grams to allow exact phrase</span>
<span class="sd">            searching. The default is off.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">formatclass</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Frequency</span>
        <span class="k">if</span> <span class="n">phrase</span><span class="p">:</span>
            <span class="n">formatclass</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Positions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">NgramAnalyzer</span><span class="p">(</span><span class="n">minsize</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">formatclass</span><span class="p">(</span><span class="n">field_boost</span><span class="o">=</span><span class="n">field_boost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">NgramAnalyzer</span><span class="p">(</span><span class="n">minsize</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="n">stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queryor</span> <span class="o">=</span> <span class="n">queryor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sortable</span><span class="p">(</span><span class="n">sortable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_parsing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parse_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">query</span>

        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_text</span><span class="p">(</span><span class="n">qstring</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;query&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">Wildcard</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">))</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">Or</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">queryor</span> <span class="k">else</span> <span class="n">query</span><span class="o">.</span><span class="n">And</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">)</span></div>


<div class="viewcode-block" id="NGRAMWORDS"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.NGRAMWORDS">[docs]</a><span class="k">class</span> <span class="nc">NGRAMWORDS</span><span class="p">(</span><span class="n">NGRAM</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configured field that chops text into words using a tokenizer,</span>
<span class="sd">    lowercases the words, and then chops the words into N-grams.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">scorable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">minsize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">maxsize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">field_boost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">tokenizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">at</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">queryor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sortable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param minsize: The minimum length of the N-grams.</span>
<span class="sd">        :param maxsize: The maximum length of the N-grams.</span>
<span class="sd">        :param stored: Whether to store the value of this field with the</span>
<span class="sd">            document. Since this field type generally contains a lot of text,</span>
<span class="sd">            you should avoid storing it with the document unless you need to,</span>
<span class="sd">            for example to allow fast excerpts in the search results.</span>
<span class="sd">        :param tokenizer: an instance of :class:`whoosh.analysis.Tokenizer`</span>
<span class="sd">            used to break the text into words.</span>
<span class="sd">        :param at: if &#39;start&#39;, only takes N-grams from the start of the word.</span>
<span class="sd">            If &#39;end&#39;, only takes N-grams from the end. Otherwise the default</span>
<span class="sd">            is to take all N-grams from each word.</span>
<span class="sd">        :param queryor: if True, combine the N-grams with an Or query. The</span>
<span class="sd">            default is to combine N-grams with an And query.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">NgramWordAnalyzer</span><span class="p">(</span><span class="n">minsize</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">,</span> <span class="n">at</span><span class="o">=</span><span class="n">at</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">Frequency</span><span class="p">(</span><span class="n">field_boost</span><span class="o">=</span><span class="n">field_boost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="n">stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queryor</span> <span class="o">=</span> <span class="n">queryor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sortable</span><span class="p">(</span><span class="n">sortable</span><span class="p">)</span></div>


<span class="c1"># Other fields</span>


<span class="k">class</span> <span class="nc">ReverseField</span><span class="p">(</span><span class="n">FieldWrapper</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subfield</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;rev_&quot;</span><span class="p">):</span>
        <span class="n">FieldWrapper</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subfield</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">subfield</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">|</span> <span class="n">analysis</span><span class="o">.</span><span class="n">ReverseTextFilter</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scorable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sortable</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">subfields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subfield</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_prefix</span><span class="p">,</span> <span class="bp">self</span>


<span class="c1"># Schema class</span>


<span class="k">class</span> <span class="nc">MetaSchema</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="n">super_new</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MetaSchema</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">MetaSchema</span><span class="p">)):</span>
            <span class="c1"># If this isn&#39;t a subclass of MetaSchema, don&#39;t do anything special</span>
            <span class="k">return</span> <span class="n">super_new</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># Create the class</span>
        <span class="n">special_attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">):</span>
                <span class="n">special_attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">new_class</span> <span class="o">=</span> <span class="n">super_new</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">special_attrs</span><span class="p">)</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;_clsfields&quot;</span><span class="p">):</span>
                <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">_clsfields</span><span class="p">)</span>
        <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
        <span class="n">new_class</span><span class="o">.</span><span class="n">_clsfields</span> <span class="o">=</span> <span class="n">fields</span>
        <span class="k">return</span> <span class="n">new_class</span>

    <span class="k">def</span> <span class="nf">schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Schema</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_clsfields</span><span class="p">)</span>


<div class="viewcode-block" id="Schema"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.Schema">[docs]</a><span class="k">class</span> <span class="nc">Schema</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents the collection of fields in an index. Maps field names to</span>
<span class="sd">    FieldType objects which define the behavior of each field.</span>

<span class="sd">    Low-level parts of the index use field numbers instead of field names for</span>
<span class="sd">    compactness. This class has several methods for converting between the</span>
<span class="sd">    field name, field number, and field object itself.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">fields</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All keyword arguments to the constructor are treated as fieldname =</span>
<span class="sd">        fieldtype pairs. The fieldtype can be an instantiated FieldType object,</span>
<span class="sd">        or a FieldType sub-class (in which case the Schema will instantiate it</span>
<span class="sd">        with the default constructor before adding it).</span>

<span class="sd">        For example::</span>

<span class="sd">            s = Schema(content = TEXT,</span>
<span class="sd">                       title = TEXT(stored = True),</span>
<span class="sd">                       tags = KEYWORD(stored = True))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subfields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dyn_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fields</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fields</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

<div class="viewcode-block" id="Schema.copy"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.Schema.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a shallow copy of the schema. The field instances are not</span>
<span class="sd">        deep copied, so they are shared between schema copies.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%r</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the field objects in this schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the field associated with the given field name.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the name is in the dictionary, just return it</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># Check if the name matches a dynamic field</span>
        <span class="k">for</span> <span class="n">expr</span><span class="p">,</span> <span class="n">fieldtype</span> <span class="ow">in</span> <span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dyn_fields</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">fieldtype</span>

        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;No field named </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of fields in this schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if a field by the given name is in this schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Defined in terms of __getitem__ so that there&#39;s only one method to</span>
        <span class="c1"># override to provide dynamic fields</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;_subfields&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;_subfields&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="Schema.items"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.Schema.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of (&quot;fieldname&quot;, field_object) pairs for the fields</span>
<span class="sd">        in this schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="o">.</span><span class="n">items</span><span class="p">())</span></div>

<div class="viewcode-block" id="Schema.names"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.Schema.names">[docs]</a>    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">check_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the names of the fields in this schema.</span>

<span class="sd">        :param check_names: (optional) sequence of field names to check</span>
<span class="sd">            whether the schema accepts them as (dynamic) field names -</span>
<span class="sd">            acceptable names will also be in the result list.</span>
<span class="sd">            Note: You may also have static field names in check_names, that</span>
<span class="sd">            won&#39;t create duplicates in the result list. Unsupported names</span>
<span class="sd">            will not be in the result list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fieldnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">check_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">check_names</span><span class="p">)</span> <span class="o">-</span> <span class="n">fieldnames</span>
            <span class="n">fieldnames</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">fieldname</span> <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">check_names</span> <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fieldnames</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">field</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

<div class="viewcode-block" id="Schema.add"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.Schema.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fieldtype</span><span class="p">,</span> <span class="n">glob</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a field to this schema.</span>

<span class="sd">        :param name: The name of the field.</span>
<span class="sd">        :param fieldtype: An instantiated fields.FieldType object, or a</span>
<span class="sd">            FieldType subclass. If you pass an instantiated object, the schema</span>
<span class="sd">            will use that as the field configuration for this field. If you</span>
<span class="sd">            pass a FieldType subclass, the schema will automatically</span>
<span class="sd">            instantiate it with the default constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the user passed a type rather than an instantiated field object,</span>
        <span class="c1"># instantiate it automatically</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">fieldtype</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fieldtype</span> <span class="o">=</span> <span class="n">fieldtype</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">raise</span> <span class="n">FieldConfigurationError</span><span class="p">(</span>
                    <span class="s2">&quot;Error: </span><span class="si">%s</span><span class="s2"> instantiating field &quot;</span> <span class="s2">&quot;</span><span class="si">%r</span><span class="s2">: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fieldtype</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fieldtype</span><span class="p">,</span> <span class="n">FieldType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FieldConfigurationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> is not a FieldType object&quot;</span> <span class="o">%</span> <span class="n">fieldtype</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_subfields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">subfield</span> <span class="ow">in</span> <span class="n">fieldtype</span><span class="o">.</span><span class="n">subfields</span><span class="p">():</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">name</span>
            <span class="n">sublist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

            <span class="c1"># Check field name</span>
            <span class="k">if</span> <span class="n">fname</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">FieldConfigurationError</span><span class="p">(</span><span class="s2">&quot;Names cannot start with _&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot; &quot;</span> <span class="ow">in</span> <span class="n">fname</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">FieldConfigurationError</span><span class="p">(</span><span class="s2">&quot;Names cannot contain spaces&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span> <span class="ow">or</span> <span class="p">(</span><span class="n">glob</span> <span class="ow">and</span> <span class="n">fname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dyn_fields</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">FieldConfigurationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> already in schema&quot;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span>

            <span class="c1"># Add the field</span>
            <span class="k">if</span> <span class="n">glob</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dyn_fields</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">subfield</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fieldtype</span><span class="o">.</span><span class="n">on_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">subfield</span></div>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span><span class="o">.</span><span class="n">on_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subfields</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">subname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subfields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">subname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">subname</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subfields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dyn_fields</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dyn_fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;No field named </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fieldname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">indexable_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subfields</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subfields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]:</span>
                <span class="k">yield</span> <span class="n">subname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">subname</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use __getitem__ here instead of getting it directly from _fields</span>
            <span class="c1"># because it might be a glob</span>
            <span class="k">yield</span> <span class="n">fieldname</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">has_scorable_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">ftype</span><span class="o">.</span><span class="n">scorable</span> <span class="k">for</span> <span class="n">ftype</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Schema.stored_names"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.Schema.stored_names">[docs]</a>    <span class="k">def</span> <span class="nf">stored_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the names of fields that are stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">stored</span><span class="p">]</span></div>

<div class="viewcode-block" id="Schema.scorable_names"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.Schema.scorable_names">[docs]</a>    <span class="k">def</span> <span class="nf">scorable_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the names of fields that store field</span>
<span class="sd">        lengths.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">scorable</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="SchemaClass"><a class="viewcode-back" href="../../api/fields.html#whoosh.fields.SchemaClass">[docs]</a><span class="k">class</span> <span class="nc">SchemaClass</span><span class="p">(</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">MetaSchema</span><span class="p">,</span> <span class="n">Schema</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Allows you to define a schema using declarative syntax, similar to</span>
<span class="sd">    Django models::</span>

<span class="sd">        class MySchema(SchemaClass):</span>
<span class="sd">            path = ID</span>
<span class="sd">            date = DATETIME</span>
<span class="sd">            content = TEXT</span>

<span class="sd">    You can use inheritance to share common fields between schemas::</span>

<span class="sd">        class Parent(SchemaClass):</span>
<span class="sd">            path = ID(stored=True)</span>
<span class="sd">            date = DATETIME</span>

<span class="sd">        class Child1(Parent):</span>
<span class="sd">            content = TEXT(positions=False)</span>

<span class="sd">        class Child2(Parent):</span>
<span class="sd">            tags = KEYWORD</span>

<span class="sd">    This class overrides ``__new__`` so instantiating your sub-class always</span>
<span class="sd">    results in an instance of ``Schema``.</span>

<span class="sd">    &gt;&gt;&gt; class MySchema(SchemaClass):</span>
<span class="sd">    ...     title = TEXT(stored=True)</span>
<span class="sd">    ...     content = TEXT</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; s = MySchema()</span>
<span class="sd">    &gt;&gt;&gt; type(s)</span>
<span class="sd">    &lt;class &#39;whoosh.fields.Schema&#39;&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Schema</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Schema</span><span class="p">)</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_clsfields&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>


<span class="k">def</span> <span class="nf">ensure_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">Schema</span><span class="p">):</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">schema</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">Schema</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">FieldConfigurationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> is not a Schema&quot;</span> <span class="o">%</span> <span class="n">schema</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">schema</span>


<span class="k">def</span> <span class="nf">merge_fielddict</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
    <span class="n">keyset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">keyset</span><span class="p">:</span>
        <span class="n">field1</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">field2</span> <span class="o">=</span> <span class="n">d2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">field1</span> <span class="ow">and</span> <span class="n">field2</span> <span class="ow">and</span> <span class="n">field1</span> <span class="o">!=</span> <span class="n">field2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Inconsistent field </span><span class="si">%r</span><span class="s2">: </span><span class="si">%r</span><span class="s2"> != </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">))</span>
        <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">field1</span> <span class="ow">or</span> <span class="n">field2</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">merge_schema</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">Schema</span><span class="p">()</span>
    <span class="n">schema</span><span class="o">.</span><span class="n">_fields</span> <span class="o">=</span> <span class="n">merge_fielddict</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">_fields</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span>
    <span class="n">schema</span><span class="o">.</span><span class="n">_dyn_fields</span> <span class="o">=</span> <span class="n">merge_fielddict</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">_dyn_fields</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">_dyn_fields</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">schema</span>


<span class="k">def</span> <span class="nf">merge_schemas</span><span class="p">(</span><span class="n">schemas</span><span class="p">):</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">schemas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">schemas</span><span class="p">)):</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">merge_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">schemas</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">schema</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2007-2012 Matt Chaput.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>