<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>whoosh.searching &mdash; Whoosh-Reloaded 3.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Whoosh-Reloaded
          </a>
              <div class="version">
                3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../releases/index.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction to Whoosh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../schema.html">Designing a schema</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../indexing.html">How to index documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../searching.html">How to search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parsing.html">Parsing user queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../querylang.html">The default query language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dates.html">Indexing and parsing dates/times</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../query.html">Query objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../analysis.html">About analyzers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stemming.html">Stemming, variations, and accent folding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ngrams.html">Indexing and searching N-grams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../facets.html">Sorting and faceting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../highlight.html">How to create highlighted search result excerpts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../keywords.html">Query expansion and Key word extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spelling.html">“Did you mean… ?” Correcting errors in user queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fieldcaches.html">Field caches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../batch.html">Tips for speeding up batch indexing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../threads.html">Concurrency, locking, and versioning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nested.html">Indexing and searching document hierarchies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../recipes.html">Whoosh recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/api.html">Whoosh API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tech/index.html">Technical notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Whoosh-Reloaded</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">whoosh.searching</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for whoosh.searching</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2007 Matt Chaput. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1">#    1. Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#       this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#    2. Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#       notice, this list of conditions and the following disclaimer in the</span>
<span class="c1">#       documentation and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY MATT CHAPUT ``AS IS&#39;&#39; AND ANY EXPRESS OR</span>
<span class="c1"># IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="c1"># MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO</span>
<span class="c1"># EVENT SHALL MATT CHAPUT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="c1"># INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="c1"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,</span>
<span class="c1"># OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="c1"># LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="c1"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</span>
<span class="c1"># EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1"># The views and conclusions contained in the software and documentation are</span>
<span class="c1"># those of the authors and should not be interpreted as representing official</span>
<span class="c1"># policies, either expressed or implied, of Matt Chaput.</span>

<span class="sd">&quot;&quot;&quot;This module contains classes and functions related to searching the index.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">ceil</span>

<span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">classify</span><span class="p">,</span> <span class="n">highlight</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">scoring</span>
<span class="kn">from</span> <span class="nn">whoosh.idsets</span> <span class="kn">import</span> <span class="n">BitSet</span><span class="p">,</span> <span class="n">DocIdSet</span>
<span class="kn">from</span> <span class="nn">whoosh.reading</span> <span class="kn">import</span> <span class="n">TermNotFound</span>


<div class="viewcode-block" id="NoTermsException"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.NoTermsException">[docs]</a><span class="k">class</span> <span class="nc">NoTermsException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Exception raised you try to access matched terms on a :class:`Results`</span>
<span class="sd">    object was created without them. To record which terms matched in which</span>
<span class="sd">    document, you need to call the :meth:`Searcher.search` method with</span>
<span class="sd">    ``terms=True``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Results were created without recording terms&quot;</span></div>


<div class="viewcode-block" id="TimeLimit"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.TimeLimit">[docs]</a><span class="k">class</span> <span class="nc">TimeLimit</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised by :class:`TimeLimitedCollector` if the time limit is reached</span>
<span class="sd">    before the search finishes. If you have a reference to the collector, you</span>
<span class="sd">    can get partial results by calling :meth:`TimeLimitedCollector.results`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<span class="c1"># Context class</span>


<span class="k">class</span> <span class="nc">SearchContext</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A container for information about the current search that may be used</span>
<span class="sd">    by the collector or the query objects to change how they operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">needs_current</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">top_query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param needs_current: if True, the search requires that the matcher</span>
<span class="sd">            tree be &quot;valid&quot; and able to access information about the current</span>
<span class="sd">            match. For queries during matcher instantiation, this means they</span>
<span class="sd">            should not instantiate a matcher that doesn&#39;t allow access to the</span>
<span class="sd">            current match&#39;s value, weight, and so on. For collectors, this</span>
<span class="sd">            means they should advanced the matcher doc-by-doc rather than using</span>
<span class="sd">            shortcut methods such as all_ids().</span>
<span class="sd">        :param weighting: the Weighting object to use for scoring documents.</span>
<span class="sd">        :param top_query: a reference to the top-level query object.</span>
<span class="sd">        :param limit: the number of results requested by the user.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">needs_current</span> <span class="o">=</span> <span class="n">needs_current</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span> <span class="o">=</span> <span class="n">weighting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_query</span> <span class="o">=</span> <span class="n">top_query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="si">!r}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ctx</span>


<span class="c1"># Searcher class</span>


<div class="viewcode-block" id="Searcher"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher">[docs]</a><span class="k">class</span> <span class="nc">Searcher</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wraps an :class:`~whoosh.reading.IndexReader` object and provides</span>
<span class="sd">    methods for searching the index.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reader</span><span class="p">,</span>
        <span class="n">weighting</span><span class="o">=</span><span class="n">scoring</span><span class="o">.</span><span class="n">BM25F</span><span class="p">,</span>
        <span class="n">closereader</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fromindex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param reader: An :class:`~whoosh.reading.IndexReader` object for</span>
<span class="sd">            the index to search.</span>
<span class="sd">        :param weighting: A :class:`whoosh.scoring.Weighting` object to use to</span>
<span class="sd">            score found documents.</span>
<span class="sd">        :param closereader: Whether the underlying reader will be closed when</span>
<span class="sd">            the searcher is closed.</span>
<span class="sd">        :param fromindex: An optional reference to the index of the underlying</span>
<span class="sd">            reader. This is required for :meth:`Searcher.up_to_date` and</span>
<span class="sd">            :meth:`Searcher.refresh` to work.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span> <span class="o">=</span> <span class="n">reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closereader</span> <span class="o">=</span> <span class="n">closereader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span> <span class="o">=</span> <span class="n">fromindex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_doccount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="o">.</span><span class="n">doc_count_all</span><span class="p">()</span>
        <span class="c1"># Cache for PostingCategorizer objects (supports fields without columns)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_field_caches</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">schema</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idf_cache</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_idf_cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filter_cache</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_filter_cache</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="o">.</span><span class="n">schema</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idf_cache</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filter_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">weighting</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span> <span class="o">=</span> <span class="n">weighting</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span> <span class="o">=</span> <span class="n">weighting</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">leafreaders</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subsearchers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leafreaders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="o">.</span><span class="n">leaf_readers</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subsearchers</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsearcher</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">offset</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leafreaders</span>
            <span class="p">]</span>

        <span class="c1"># Copy attributes/methods from wrapped reader</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">&quot;stored_fields&quot;</span><span class="p">,</span>
            <span class="s2">&quot;all_stored_fields&quot;</span><span class="p">,</span>
            <span class="s2">&quot;has_vector&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vector&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vector_as&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lexicon&quot;</span><span class="p">,</span>
            <span class="s2">&quot;field_terms&quot;</span><span class="p">,</span>
            <span class="s2">&quot;frequency&quot;</span><span class="p">,</span>
            <span class="s2">&quot;doc_frequency&quot;</span><span class="p">,</span>
            <span class="s2">&quot;term_info&quot;</span><span class="p">,</span>
            <span class="s2">&quot;doc_field_length&quot;</span><span class="p">,</span>
            <span class="s2">&quot;corrector&quot;</span><span class="p">,</span>
            <span class="s2">&quot;iter_docs&quot;</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc_info</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_subsearcher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">reader</span><span class="p">,</span> <span class="n">fromindex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_offset_for_subsearcher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subsearcher</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsearchers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ss</span> <span class="ow">is</span> <span class="n">subsearcher</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="nf">leaf_searchers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsearchers</span>

    <span class="k">def</span> <span class="nf">is_atomic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">has_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

<div class="viewcode-block" id="Searcher.get_parent"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.get_parent">[docs]</a>    <span class="k">def</span> <span class="nf">get_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the parent of this searcher (if has_parent() is True), or</span>
<span class="sd">        else self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_parent</span><span class="p">():</span>
            <span class="c1"># Call the weak reference to get the parent searcher</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Searcher.doc_count"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.doc_count">[docs]</a>    <span class="k">def</span> <span class="nf">doc_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of UNDELETED documents in the index.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="o">.</span><span class="n">doc_count</span><span class="p">()</span></div>

<div class="viewcode-block" id="Searcher.doc_count_all"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.doc_count_all">[docs]</a>    <span class="k">def</span> <span class="nf">doc_count_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the total number of documents, DELETED OR UNDELETED, in</span>
<span class="sd">        the index.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doccount</span></div>

    <span class="k">def</span> <span class="nf">field_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_parent</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent</span><span class="p">()</span><span class="o">.</span><span class="n">field_length</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span><span class="o">.</span><span class="n">field_length</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">max_field_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_parent</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent</span><span class="p">()</span><span class="o">.</span><span class="n">max_field_length</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span><span class="o">.</span><span class="n">max_field_length</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>

<div class="viewcode-block" id="Searcher.up_to_date"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.up_to_date">[docs]</a>    <span class="k">def</span> <span class="nf">up_to_date</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if this Searcher represents the latest version of the</span>
<span class="sd">        index, for backends that support versioning.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No reference to index&quot;</span>
            <span class="p">)</span>  <span class="c1"># Replace generic exception with ValueError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="o">.</span><span class="n">latest_generation</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="o">.</span><span class="n">generation</span><span class="p">()</span></div>

<div class="viewcode-block" id="Searcher.refresh"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.refresh">[docs]</a>    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a fresh searcher for the latest version of the index::</span>

<span class="sd">            my_searcher = my_searcher.refresh()</span>

<span class="sd">        If the index has not changed since this searcher was created, this</span>
<span class="sd">        searcher is simply returned.</span>

<span class="sd">        This method may CLOSE underlying resources that are no longer needed</span>
<span class="sd">        by the refreshed searcher, so you CANNOT continue to use the original</span>
<span class="sd">        searcher after calling ``refresh()`` on it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No reference to index&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="o">.</span><span class="n">latest_generation</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span><span class="o">.</span><span class="n">generation</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Get a new reader, re-using resources from the current reader if</span>
        <span class="c1"># possible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">newreader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">reuse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">newreader</span><span class="p">,</span> <span class="n">fromindex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closereader</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">avg_field_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span><span class="o">.</span><span class="n">scorable</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_length</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_doccount</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="Searcher.reader"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.reader">[docs]</a>    <span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the underlying :class:`~whoosh.reading.IndexReader`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span></div>

<div class="viewcode-block" id="Searcher.context"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.context">[docs]</a>    <span class="k">def</span> <span class="nf">context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a :class:`SearchContext` for this searcher.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;weighting&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;weighting&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span>

        <span class="k">return</span> <span class="n">SearchContext</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Searcher.boolean_context"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.boolean_context">[docs]</a>    <span class="k">def</span> <span class="nf">boolean_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut returns a SearchContext set for unscored (boolean)</span>
<span class="sd">        searching.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">needs_current</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="Searcher.postings"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.postings">[docs]</a>    <span class="k">def</span> <span class="nf">postings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a :class:`whoosh.matching.Matcher` for the postings of the</span>
<span class="sd">        given term. Unlike the :func:`whoosh.reading.IndexReader.postings`</span>
<span class="sd">        method, this method automatically sets the scoring functions on the</span>
<span class="sd">        matcher from the searcher&#39;s weighting object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">weighting</span> <span class="o">=</span> <span class="n">weighting</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span>
        <span class="n">globalscorer</span> <span class="o">=</span> <span class="n">weighting</span><span class="o">.</span><span class="n">scorer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">qf</span><span class="o">=</span><span class="n">qf</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="o">.</span><span class="n">postings</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">scorer</span><span class="o">=</span><span class="n">globalscorer</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">whoosh.matching</span> <span class="kn">import</span> <span class="n">MultiMatcher</span>

            <span class="n">matchers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">docoffsets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">term</span> <span class="o">=</span> <span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">subsearcher</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsearchers</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">subsearcher</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                    <span class="c1"># Make a segment-specific scorer; the scorer should call</span>
                    <span class="c1"># searcher.parent() to get global stats</span>
                    <span class="n">scorer</span> <span class="o">=</span> <span class="n">weighting</span><span class="o">.</span><span class="n">scorer</span><span class="p">(</span><span class="n">subsearcher</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">qf</span><span class="o">=</span><span class="n">qf</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">postings</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">scorer</span><span class="o">=</span><span class="n">scorer</span><span class="p">)</span>
                    <span class="n">matchers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                    <span class="n">docoffsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">matchers</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TermNotFound</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">MultiMatcher</span><span class="p">(</span><span class="n">matchers</span><span class="p">,</span> <span class="n">docoffsets</span><span class="p">,</span> <span class="n">globalscorer</span><span class="p">)</span></div>

<div class="viewcode-block" id="Searcher.idf"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.idf">[docs]</a>    <span class="k">def</span> <span class="nf">idf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the Inverse Document Frequency of the current term (calls</span>
<span class="sd">        idf() on the searcher&#39;s Weighting object).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This method just calls the Weighting object&#39;s idf() method, but</span>
        <span class="c1"># caches the result. So Weighting objects should call *this* method</span>
        <span class="c1"># which will then call *their own* idf() methods.</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idf_cache</span>
        <span class="n">term</span> <span class="o">=</span> <span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">term</span><span class="p">]</span>

        <span class="n">idf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">idf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">=</span> <span class="n">idf</span>
        <span class="k">return</span> <span class="n">idf</span></div>

<div class="viewcode-block" id="Searcher.document"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.document">[docs]</a>    <span class="k">def</span> <span class="nf">document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience method returns the stored fields of a document</span>
<span class="sd">        matching the given keyword arguments, where the keyword keys are</span>
<span class="sd">        field names and the values are terms that must appear in the field.</span>

<span class="sd">        This method is equivalent to::</span>

<span class="sd">            searcher.stored_fields(searcher.document_number(&lt;keyword args&gt;))</span>

<span class="sd">        Where Searcher.documents() returns a generator, this function returns</span>
<span class="sd">        either a dictionary or None. Use it when you assume the given keyword</span>
<span class="sd">        arguments either match zero or one documents (i.e. at least one of the</span>
<span class="sd">        fields is a unique key).</span>

<span class="sd">        &gt;&gt;&gt; stored_fields = searcher.document(path=u&quot;/a/b&quot;)</span>
<span class="sd">        &gt;&gt;&gt; if stored_fields:</span>
<span class="sd">        ...   print(stored_fields[&#39;title&#39;])</span>
<span class="sd">        ... else:</span>
<span class="sd">        ...   print(&quot;There is no document with the path /a/b&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">documents</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="Searcher.documents"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.documents">[docs]</a>    <span class="k">def</span> <span class="nf">documents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience method returns the stored fields of a document</span>
<span class="sd">        matching the given keyword arguments, where the keyword keys are field</span>
<span class="sd">        names and the values are terms that must appear in the field.</span>

<span class="sd">        Returns a generator of dictionaries containing the stored fields of any</span>
<span class="sd">        documents matching the keyword arguments. If you do not specify any</span>
<span class="sd">        arguments (``Searcher.documents()``), this method will yield **all**</span>
<span class="sd">        documents.</span>

<span class="sd">        &gt;&gt;&gt; for stored_fields in searcher.documents(emailto=u&quot;matt@whoosh.ca&quot;):</span>
<span class="sd">        ...   print(&quot;Email subject:&quot;, stored_fields[&#39;subject&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ixreader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">ixreader</span><span class="o">.</span><span class="n">stored_fields</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span> <span class="k">for</span> <span class="n">docnum</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">document_numbers</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_kw_to_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">kw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_query_for_kw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="n">subqueries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">subqueries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">subqueries</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">subqueries</span><span class="p">)</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">Every</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span>

<div class="viewcode-block" id="Searcher.document_number"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.document_number">[docs]</a>    <span class="k">def</span> <span class="nf">document_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the document number of the document matching the given</span>
<span class="sd">        keyword arguments, where the keyword keys are field names and the</span>
<span class="sd">        values are terms that must appear in the field.</span>

<span class="sd">        &gt;&gt;&gt; docnum = searcher.document_number(path=u&quot;/a/b&quot;)</span>

<span class="sd">        Where Searcher.document_numbers() returns a generator, this function</span>
<span class="sd">        returns either an int or None. Use it when you assume the given keyword</span>
<span class="sd">        arguments either match zero or one documents (i.e. at least one of the</span>
<span class="sd">        fields is a unique key).</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># In the common case where only one keyword was given, just use</span>
        <span class="c1"># first_id() instead of building a query.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_kw_to_text</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span><span class="o">.</span><span class="n">first_id</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">TermNotFound</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_for_kw</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">matcher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boolean_context</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_active</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">id</span><span class="p">()</span></div>

<div class="viewcode-block" id="Searcher.document_numbers"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.document_numbers">[docs]</a>    <span class="k">def</span> <span class="nf">document_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a generator of the document numbers for documents matching</span>
<span class="sd">        the given keyword arguments, where the keyword keys are field names and</span>
<span class="sd">        the values are terms that must appear in the field. If you do not</span>
<span class="sd">        specify any arguments (``Searcher.document_numbers()``), this method</span>
<span class="sd">        will yield **all** document numbers.</span>

<span class="sd">        &gt;&gt;&gt; docnums = list(searcher.document_numbers(emailto=&quot;matt@whoosh.ca&quot;))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_kw_to_text</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs_for_query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_query_for_kw</span><span class="p">(</span><span class="n">kw</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_find_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uniques</span><span class="p">):</span>
        <span class="c1"># uniques is a list of (&quot;unique_field_name&quot;, &quot;field_value&quot;) tuples</span>
        <span class="n">delset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">uniques</span><span class="p">:</span>
            <span class="n">docnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">document_number</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">docnum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">delset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">delset</span>

    <span class="k">def</span> <span class="nf">_query_to_comb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fq</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BitSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docs_for_query</span><span class="p">(</span><span class="n">fq</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">doc_count_all</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_filter_to_comb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">DocIdSet</span><span class="p">)):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Results</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">docs</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ResultsPage</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">docs</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">Query</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_to_comb</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know what to do with filter object </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">c</span>

<div class="viewcode-block" id="Searcher.suggest"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.suggest">[docs]</a>    <span class="k">def</span> <span class="nf">suggest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">maxdist</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a sorted list of suggested corrections for the given</span>
<span class="sd">        mis-typed word ``text`` based on the contents of the given field::</span>

<span class="sd">            &gt;&gt;&gt; searcher.suggest(&quot;content&quot;, &quot;specail&quot;)</span>
<span class="sd">            [&quot;special&quot;]</span>

<span class="sd">        This is a convenience method. If you are planning to get suggestions</span>
<span class="sd">        for multiple words in the same field, it is more efficient to get a</span>
<span class="sd">        :class:`~whoosh.spelling.Corrector` object and use it directly::</span>

<span class="sd">            corrector = searcher.corrector(&quot;fieldname&quot;)</span>
<span class="sd">            for word in words:</span>
<span class="sd">                print(corrector.suggest(word))</span>

<span class="sd">        :param limit: only return up to this many suggestions. If there are not</span>
<span class="sd">            enough terms in the field within ``maxdist`` of the given word, the</span>
<span class="sd">            returned list will be shorter than this number.</span>
<span class="sd">        :param maxdist: the largest edit distance from the given word to look</span>
<span class="sd">            at. Numbers higher than 2 are not very effective or efficient.</span>
<span class="sd">        :param prefix: require suggestions to share a prefix of this length</span>
<span class="sd">            with the given word. This is often justifiable since most</span>
<span class="sd">            misspellings do not involve the first letter of the word. Using a</span>
<span class="sd">            prefix dramatically decreases the time it takes to generate the</span>
<span class="sd">            list of words.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span><span class="o">.</span><span class="n">corrector</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">suggest</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">maxdist</span><span class="o">=</span><span class="n">maxdist</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span></div>

<div class="viewcode-block" id="Searcher.key_terms"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.key_terms">[docs]</a>    <span class="k">def</span> <span class="nf">key_terms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">docnums</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">numterms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">classify</span><span class="o">.</span><span class="n">Bo1Model</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the &#39;numterms&#39; most important terms from the documents</span>
<span class="sd">        listed (by number) in &#39;docnums&#39;. You can get document numbers for the</span>
<span class="sd">        documents your interested in with the document_number() and</span>
<span class="sd">        document_numbers() methods.</span>

<span class="sd">        &quot;Most important&quot; is generally defined as terms that occur frequently in</span>
<span class="sd">        the top hits but relatively infrequently in the collection as a whole.</span>

<span class="sd">        &gt;&gt;&gt; docnum = searcher.document_number(path=u&quot;/a/b&quot;)</span>
<span class="sd">        &gt;&gt;&gt; keywords_and_scores = searcher.key_terms([docnum], &quot;content&quot;)</span>

<span class="sd">        This method returns a list of (&quot;term&quot;, score) tuples. The score may be</span>
<span class="sd">        useful if you want to know the &quot;strength&quot; of the key terms, however to</span>
<span class="sd">        just get the terms themselves you can just do this:</span>

<span class="sd">        &gt;&gt;&gt; kws = [kw for kw, score in searcher.key_terms([docnum], &quot;content&quot;)]</span>

<span class="sd">        :param fieldname: Look at the terms in this field. This field must</span>
<span class="sd">            store vectors.</span>
<span class="sd">        :param docnums: A sequence of document numbers specifying which</span>
<span class="sd">            documents to extract key terms from.</span>
<span class="sd">        :param numterms: Return this number of important terms.</span>
<span class="sd">        :param model: The classify.ExpansionModel to use. See the classify</span>
<span class="sd">            module.</span>
<span class="sd">        :param normalize: normalize the scores.</span>
<span class="sd">        :returns: a list of (&quot;term&quot;, score) tuples.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">expander</span> <span class="o">=</span> <span class="n">classify</span><span class="o">.</span><span class="n">Expander</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">docnum</span> <span class="ow">in</span> <span class="n">docnums</span><span class="p">:</span>
            <span class="n">expander</span><span class="o">.</span><span class="n">add_document</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expander</span><span class="o">.</span><span class="n">expanded_terms</span><span class="p">(</span><span class="n">numterms</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">)</span></div>

<div class="viewcode-block" id="Searcher.key_terms_from_text"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.key_terms_from_text">[docs]</a>    <span class="k">def</span> <span class="nf">key_terms_from_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">numterms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">classify</span><span class="o">.</span><span class="n">Bo1Model</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the &#39;numterms&#39; most important terms from the given text.</span>

<span class="sd">        :param numterms: Return this number of important terms.</span>
<span class="sd">        :param model: The classify.ExpansionModel to use. See the classify</span>
<span class="sd">            module.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">expander</span> <span class="o">=</span> <span class="n">classify</span><span class="o">.</span><span class="n">Expander</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>
        <span class="n">expander</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expander</span><span class="o">.</span><span class="n">expanded_terms</span><span class="p">(</span><span class="n">numterms</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">)</span></div>

<div class="viewcode-block" id="Searcher.more_like"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.more_like">[docs]</a>    <span class="k">def</span> <span class="nf">more_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">docnum</span><span class="p">,</span>
        <span class="n">fieldname</span><span class="p">,</span>
        <span class="n">text</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">top</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">numterms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">classify</span><span class="o">.</span><span class="n">Bo1Model</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a :class:`Results` object containing documents similar to</span>
<span class="sd">        the given document, based on &quot;key terms&quot; in the given field::</span>

<span class="sd">            # Get the ID for the document you&#39;re interested in</span>
<span class="sd">            docnum = search.document_number(path=u&quot;/a/b/c&quot;)</span>

<span class="sd">            r = searcher.more_like(docnum)</span>

<span class="sd">            print(&quot;Documents like&quot;, searcher.stored_fields(docnum)[&quot;title&quot;])</span>
<span class="sd">            for hit in r:</span>
<span class="sd">                print(hit[&quot;title&quot;])</span>

<span class="sd">        :param fieldname: the name of the field to use to test similarity.</span>
<span class="sd">        :param text: by default, the method will attempt to load the contents</span>
<span class="sd">            of the field from the stored fields for the document, or from a</span>
<span class="sd">            term vector. If the field isn&#39;t stored or vectored in the index,</span>
<span class="sd">            but you have access to the text another way (for example, loading</span>
<span class="sd">            from a file or a database), you can supply it using the ``text``</span>
<span class="sd">            parameter.</span>
<span class="sd">        :param top: the number of results to return.</span>
<span class="sd">        :param numterms: the number of &quot;key terms&quot; to extract from the hit and</span>
<span class="sd">            search for. Using more terms is slower but gives potentially more</span>
<span class="sd">            and more accurate results.</span>
<span class="sd">        :param model: (expert) a :class:`whoosh.classify.ExpansionModel` to use</span>
<span class="sd">            to compute &quot;key terms&quot;.</span>
<span class="sd">        :param normalize: whether to normalize term weights.</span>
<span class="sd">        :param filter: a query, Results object, or set of docnums. The results</span>
<span class="sd">            will only contain documents that are also in the filter object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">kts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_terms_from_text</span><span class="p">(</span>
                <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">numterms</span><span class="o">=</span><span class="n">numterms</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_terms</span><span class="p">(</span>
                <span class="p">[</span><span class="n">docnum</span><span class="p">],</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">numterms</span><span class="o">=</span><span class="n">numterms</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
            <span class="p">)</span>
        <span class="c1"># Create an Or query from the key terms</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">Or</span><span class="p">(</span>
            <span class="p">[</span><span class="n">query</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">kts</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">top</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="nb">filter</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">{</span><span class="n">docnum</span><span class="p">})</span></div>

<div class="viewcode-block" id="Searcher.search_page"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.search_page">[docs]</a>    <span class="k">def</span> <span class="nf">search_page</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">pagenum</span><span class="p">,</span> <span class="n">pagelen</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method is Like the :meth:`Searcher.search` method, but returns</span>
<span class="sd">        a :class:`ResultsPage` object. This is a convenience function for</span>
<span class="sd">        getting a certain &quot;page&quot; of the results for the given query, which is</span>
<span class="sd">        often useful in web search interfaces.</span>

<span class="sd">        For example::</span>

<span class="sd">            querystring = request.get(&quot;q&quot;)</span>
<span class="sd">            query = queryparser.parse(&quot;content&quot;, querystring)</span>

<span class="sd">            pagenum = int(request.get(&quot;page&quot;, 1))</span>
<span class="sd">            pagelen = int(request.get(&quot;perpage&quot;, 10))</span>

<span class="sd">            results = searcher.search_page(query, pagenum, pagelen=pagelen)</span>
<span class="sd">            print(&quot;Page %d of %d&quot; % (results.pagenum, results.pagecount))</span>
<span class="sd">            print(&quot;Showing results %d-%d of %d&quot;</span>
<span class="sd">                  % (results.offset + 1, results.offset + results.pagelen + 1,</span>
<span class="sd">                     len(results)))</span>
<span class="sd">            for hit in results:</span>
<span class="sd">                print(&quot;%d: %s&quot; % (hit.rank + 1, hit[&quot;title&quot;]))</span>

<span class="sd">        (Note that results.pagelen might be less than the pagelen argument if</span>
<span class="sd">        there aren&#39;t enough results to fill a page.)</span>

<span class="sd">        Any additional keyword arguments you supply are passed through to</span>
<span class="sd">        :meth:`Searcher.search`. For example, you can get paged results of a</span>
<span class="sd">        sorted search::</span>

<span class="sd">            results = searcher.search_page(q, 2, sortedby=&quot;date&quot;, reverse=True)</span>

<span class="sd">        Currently, searching for page 100 with pagelen of 10 takes the same</span>
<span class="sd">        amount of time as using :meth:`Searcher.search` to find the first 1000</span>
<span class="sd">        results. That is, this method does not have any special optimizations</span>
<span class="sd">        or efficiencies for getting a page from the middle of the full results</span>
<span class="sd">        list. (A future enhancement may allow using previous page results to</span>
<span class="sd">        improve the efficiency of finding the next page.)</span>

<span class="sd">        This method will raise a ``ValueError`` if you ask for a page number</span>
<span class="sd">        higher than the number of pages in the resulting query.</span>

<span class="sd">        :param query: the :class:`whoosh.query.Query` object to match.</span>
<span class="sd">        :param pagenum: the page number to retrieve, starting at ``1`` for the</span>
<span class="sd">            first page.</span>
<span class="sd">        :param pagelen: the number of results per page.</span>
<span class="sd">        :returns: :class:`ResultsPage`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">pagenum</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pagenum must be &gt;= 1&quot;</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">pagenum</span> <span class="o">*</span> <span class="n">pagelen</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ResultsPage</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">pagenum</span><span class="p">,</span> <span class="n">pagelen</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">defaultfield</span><span class="p">,</span> <span class="n">querystring</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">whoosh.qparser</span> <span class="kn">import</span> <span class="n">QueryParser</span>

        <span class="n">qp</span> <span class="o">=</span> <span class="n">QueryParser</span><span class="p">(</span><span class="n">defaultfield</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ixreader</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">qp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">querystring</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Searcher.docs_for_query"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.docs_for_query">[docs]</a>    <span class="k">def</span> <span class="nf">docs_for_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">for_deletion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an iterator of document numbers for documents matching the</span>
<span class="sd">        given :class:`whoosh.query.Query` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If we&#39;re getting the document numbers so we can delete them, use the</span>
        <span class="c1"># deletion_docs method instead of docs; this lets special queries</span>
        <span class="c1"># (e.g. nested queries) override what gets deleted</span>
        <span class="k">if</span> <span class="n">for_deletion</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">deletion_docs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">docs</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsearchers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsearchers</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">docnum</span> <span class="ow">in</span> <span class="n">method</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">docnum</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">docnum</span> <span class="ow">in</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">docnum</span></div>

<div class="viewcode-block" id="Searcher.collector"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.collector">[docs]</a>    <span class="k">def</span> <span class="nf">collector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">sortedby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">groupedby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collapse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collapse_limit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">collapse_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">terms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">maptype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scored</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Low-level method: returns a configured</span>
<span class="sd">        :class:`whoosh.collectors.Collector` object based on the given</span>
<span class="sd">        arguments. You can use this object with</span>
<span class="sd">        :meth:`Searcher.search_with_collector` to search.</span>

<span class="sd">        See the documentation for the :meth:`Searcher.search` method for a</span>
<span class="sd">        description of the parameters.</span>

<span class="sd">        This method may be useful to get a basic collector object and then wrap</span>
<span class="sd">        it with another collector from ``whoosh.collectors`` or with a custom</span>
<span class="sd">        collector of your own::</span>

<span class="sd">            # Equivalent of</span>
<span class="sd">            # results = mysearcher.search(myquery, limit=10)</span>
<span class="sd">            # but with a time limt...</span>

<span class="sd">            # Create a TopCollector</span>
<span class="sd">            c = mysearcher.collector(limit=10)</span>

<span class="sd">            # Wrap it with a TimeLimitedCollector with a time limit of</span>
<span class="sd">            # 10.5 seconds</span>
<span class="sd">            from whoosh.collectors import TimeLimitedCollector</span>
<span class="sd">            c = TimeLimitCollector(c, 10.5)</span>

<span class="sd">            # Search using the custom collector</span>
<span class="sd">            results = mysearcher.search_with_collector(myquery, c)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">collectors</span>

        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">limit</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;limit must be &gt;= 1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">scored</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sortedby</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">collectors</span><span class="o">.</span><span class="n">UnsortedCollector</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">sortedby</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">collectors</span><span class="o">.</span><span class="n">SortingCollector</span><span class="p">(</span><span class="n">sortedby</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">groupedby</span> <span class="ow">or</span> <span class="n">reverse</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">limit</span> <span class="ow">or</span> <span class="n">limit</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc_count</span><span class="p">():</span>
            <span class="c1"># A collector that gathers every matching document</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">collectors</span><span class="o">.</span><span class="n">UnlimitedCollector</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># A collector that uses block quality optimizations and a heap</span>
            <span class="c1"># queue to only collect the top N documents</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">collectors</span><span class="o">.</span><span class="n">TopCollector</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">usequality</span><span class="o">=</span><span class="n">optimize</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">groupedby</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">collectors</span><span class="o">.</span><span class="n">FacetCollector</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">groupedby</span><span class="p">,</span> <span class="n">maptype</span><span class="o">=</span><span class="n">maptype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">collectors</span><span class="o">.</span><span class="n">TermsCollector</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">collapse</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">collectors</span><span class="o">.</span><span class="n">CollapseCollector</span><span class="p">(</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">collapse</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">collapse_limit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">collapse_order</span>
            <span class="p">)</span>

        <span class="c1"># Filtering wraps last so it sees the docs first</span>
        <span class="k">if</span> <span class="nb">filter</span> <span class="ow">or</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">collectors</span><span class="o">.</span><span class="n">FilterCollector</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span></div>

<div class="viewcode-block" id="Searcher.search"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.search">[docs]</a>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Runs a :class:`whoosh.query.Query` object on this searcher and</span>
<span class="sd">        returns a :class:`Results` object. See :doc:`/searching` for more</span>
<span class="sd">        information.</span>

<span class="sd">        This method takes many keyword arguments (documented below).</span>

<span class="sd">        See :doc:`/facets` for information on using ``sortedby`` and/or</span>
<span class="sd">        ``groupedby``. See :ref:`collapsing` for more information on using</span>
<span class="sd">        ``collapse``, ``collapse_limit``, and ``collapse_order``.</span>

<span class="sd">        :param query: a :class:`whoosh.query.Query` object to use to match</span>
<span class="sd">            documents.</span>
<span class="sd">        :param limit: the maximum number of documents to score. If you&#39;re only</span>
<span class="sd">            interested in the top N documents, you can set limit=N to limit the</span>
<span class="sd">            scoring for a faster search. Default is 10.</span>
<span class="sd">        :param scored: whether to score the results. Overriden by ``sortedby``.</span>
<span class="sd">            If both ``scored=False`` and ``sortedby=None``, the results will be</span>
<span class="sd">            in arbitrary order, but will usually be computed faster than</span>
<span class="sd">            scored or sorted results.</span>
<span class="sd">        :param sortedby: see :doc:`/facets`.</span>
<span class="sd">        :param reverse: Reverses the direction of the sort. Default is False.</span>
<span class="sd">        :param groupedby: see :doc:`/facets`.</span>
<span class="sd">        :param optimize: use optimizations to get faster results when possible.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        :param filter: a query, Results object, or set of docnums. The results</span>
<span class="sd">            will only contain documents that are also in the filter object.</span>
<span class="sd">        :param mask: a query, Results object, or set of docnums. The results</span>
<span class="sd">            will not contain any documents that are in the mask object.</span>
<span class="sd">        :param terms: if True, record which terms were found in each matching</span>
<span class="sd">            document. See :doc:`/searching` for more information. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        :param maptype: by default, the results of faceting with ``groupedby``</span>
<span class="sd">            is a dictionary mapping group names to ordered lists of document</span>
<span class="sd">            numbers in the group. You can pass a</span>
<span class="sd">            :class:`whoosh.sorting.FacetMap` subclass to this keyword argument</span>
<span class="sd">            to specify a different (usually faster) method for grouping. For</span>
<span class="sd">            example, ``maptype=sorting.Count`` would store only the count of</span>
<span class="sd">            documents in each group, instead of the full list of document IDs.</span>
<span class="sd">        :param collapse: a :doc:`facet &lt;/facets&gt;` to use to collapse the</span>
<span class="sd">            results. See :ref:`collapsing` for more information.</span>
<span class="sd">        :param collapse_limit: the maximum number of documents to allow with</span>
<span class="sd">            the same collapse key. See :ref:`collapsing` for more information.</span>
<span class="sd">        :param collapse_order: an optional ordering :doc:`facet &lt;/facets&gt;`</span>
<span class="sd">            to control which documents are kept when collapsing. The default</span>
<span class="sd">            (``collapse_order=None``) uses the results order (e.g. the highest</span>
<span class="sd">            scoring documents in a scored search).</span>
<span class="sd">        :rtype: :class:`Results`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Call the collector() method to build a collector based on the</span>
        <span class="c1"># parameters passed to this method</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collector</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Call the lower-level method to run the collector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_with_collector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="c1"># Return the results object from the collector</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">results</span><span class="p">()</span></div>

<div class="viewcode-block" id="Searcher.search_with_collector"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.search_with_collector">[docs]</a>    <span class="k">def</span> <span class="nf">search_with_collector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">collector</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Low-level method: runs a :class:`whoosh.query.Query` object on this</span>
<span class="sd">        searcher using the given :class:`whoosh.collectors.Collector` object</span>
<span class="sd">        to collect the results::</span>

<span class="sd">            myquery = query.Term(&quot;content&quot;, &quot;cabbage&quot;)</span>

<span class="sd">            uc = collectors.UnlimitedCollector()</span>
<span class="sd">            tc = TermsCollector(uc)</span>

<span class="sd">            mysearcher.search_with_collector(myquery, tc)</span>
<span class="sd">            print(tc.docterms)</span>
<span class="sd">            print(tc.results())</span>

<span class="sd">        Note that this method does not return a :class:`Results` object. You</span>
<span class="sd">        need to access the collector to get a results object or other</span>
<span class="sd">        information the collector might hold after the search.</span>

<span class="sd">        :param q: a :class:`whoosh.query.Query` object to use to match</span>
<span class="sd">            documents.</span>
<span class="sd">        :param collector: a :class:`whoosh.collectors.Collector` object to feed</span>
<span class="sd">            the results into.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the search context object from the searcher</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">context</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">()</span>
        <span class="c1"># Allow collector to set up based on the top-level information</span>
        <span class="n">collector</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="n">collector</span><span class="o">.</span><span class="n">run</span><span class="p">()</span></div>

<div class="viewcode-block" id="Searcher.correct_query"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Searcher.correct_query">[docs]</a>    <span class="k">def</span> <span class="nf">correct_query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">qstring</span><span class="p">,</span> <span class="n">correctors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxdist</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a corrected version of the given user query using a default</span>
<span class="sd">        :class:`whoosh.spelling.ReaderCorrector`.</span>

<span class="sd">        The default:</span>

<span class="sd">        * Corrects any words that don&#39;t appear in the index.</span>

<span class="sd">        * Takes suggestions from the words in the index. To make certain fields</span>
<span class="sd">          use custom correctors, use the ``correctors`` argument to pass a</span>
<span class="sd">          dictionary mapping field names to :class:`whoosh.spelling.Corrector`</span>
<span class="sd">          objects.</span>

<span class="sd">        Expert users who want more sophisticated correction behavior can create</span>
<span class="sd">        a custom :class:`whoosh.spelling.QueryCorrector` and use that instead</span>
<span class="sd">        of this method.</span>

<span class="sd">        Returns a :class:`whoosh.spelling.Correction` object with a ``query``</span>
<span class="sd">        attribute containing the corrected :class:`whoosh.query.Query` object</span>
<span class="sd">        and a ``string`` attributes containing the corrected query string.</span>

<span class="sd">        &gt;&gt;&gt; from whoosh import qparser, highlight</span>
<span class="sd">        &gt;&gt;&gt; qtext = &#39;mary &quot;litle lamb&quot;&#39;</span>
<span class="sd">        &gt;&gt;&gt; q = qparser.QueryParser(&quot;text&quot;, myindex.schema)</span>
<span class="sd">        &gt;&gt;&gt; mysearcher = myindex.searcher()</span>
<span class="sd">        &gt;&gt;&gt; correction = mysearcher().correct_query(q, qtext)</span>
<span class="sd">        &gt;&gt;&gt; correction.query</span>
<span class="sd">        &lt;query.And ...&gt;</span>
<span class="sd">        &gt;&gt;&gt; correction.string</span>
<span class="sd">        &#39;mary &quot;little lamb&quot;&#39;</span>
<span class="sd">        &gt;&gt;&gt; mysearcher.close()</span>

<span class="sd">        You can use the ``Correction`` object&#39;s ``format_string`` method to</span>
<span class="sd">        format the corrected query string using a</span>
<span class="sd">        :class:`whoosh.highlight.Formatter` object. For example, you can format</span>
<span class="sd">        the corrected string as HTML, emphasizing the changed words.</span>

<span class="sd">        &gt;&gt;&gt; hf = highlight.HtmlFormatter(classname=&quot;change&quot;)</span>
<span class="sd">        &gt;&gt;&gt; correction.format_string(hf)</span>
<span class="sd">        &#39;mary &quot;&lt;strong class=&quot;change term0&quot;&gt;little&lt;/strong&gt; lamb&quot;&#39;</span>

<span class="sd">        :param q: the :class:`whoosh.query.Query` object to correct.</span>
<span class="sd">        :param qstring: the original user query from which the query object was</span>
<span class="sd">            created. You can pass None instead of a string, in which the</span>
<span class="sd">            second item in the returned tuple will also be None.</span>
<span class="sd">        :param correctors: an optional dictionary mapping fieldnames to</span>
<span class="sd">            :class:`whoosh.spelling.Corrector` objects. By default, this method</span>
<span class="sd">            uses the contents of the index to spell check the terms in the</span>
<span class="sd">            query. You can use this argument to &quot;override&quot; some fields with a</span>
<span class="sd">            different correct, for example a</span>
<span class="sd">            :class:`whoosh.spelling.GraphCorrector`.</span>
<span class="sd">        :param terms: a sequence of ``(&quot;fieldname&quot;, &quot;text&quot;)`` tuples to correct</span>
<span class="sd">            in the query. By default, this method corrects terms that don&#39;t</span>
<span class="sd">            appear in the index. You can use this argument to override that</span>
<span class="sd">            behavior and explicitly specify the terms that should be corrected.</span>
<span class="sd">        :param maxdist: the maximum number of &quot;edits&quot; (insertions, deletions,</span>
<span class="sd">            subsitutions, or transpositions of letters) allowed between the</span>
<span class="sd">            original word and any suggestion. Values higher than ``2`` may be</span>
<span class="sd">            slow.</span>
<span class="sd">        :param prefix: suggested replacement words must share this number of</span>
<span class="sd">            initial characters with the original word. Increasing this even to</span>
<span class="sd">            just ``1`` can dramatically speed up suggestions, and may be</span>
<span class="sd">            justifiable since spellling mistakes rarely involve the first</span>
<span class="sd">            letter of a word.</span>
<span class="sd">        :param aliases: an optional dictionary mapping field names in the query</span>
<span class="sd">            to different field names to use as the source of spelling</span>
<span class="sd">            suggestions. The mappings in ``correctors`` are applied after this.</span>
<span class="sd">        :rtype: :class:`whoosh.spelling.Correction`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span>

        <span class="c1"># Dictionary of field name alias mappings</span>
        <span class="k">if</span> <span class="n">aliases</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aliases</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Dictionary of custom per-field correctors</span>
        <span class="k">if</span> <span class="n">correctors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">correctors</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Remap correctors dict according to aliases</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">corr</span> <span class="ow">in</span> <span class="n">correctors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">fieldname</span> <span class="o">=</span> <span class="n">aliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr</span>
        <span class="n">correctors</span> <span class="o">=</span> <span class="n">d</span>

        <span class="c1"># Fill in default corrector objects for fields that don&#39;t have a custom</span>
        <span class="c1"># one in the &quot;correctors&quot; dictionary</span>
        <span class="n">fieldnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">names</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">fieldnames</span><span class="p">:</span>
            <span class="n">fieldname</span> <span class="o">=</span> <span class="n">aliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">correctors</span><span class="p">:</span>
                <span class="n">correctors</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span><span class="o">.</span><span class="n">corrector</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>

        <span class="c1"># Get any missing terms in the query in the fields we&#39;re correcting</span>
        <span class="k">if</span> <span class="n">terms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">all_tokens</span><span class="p">():</span>
                <span class="n">aname</span> <span class="o">=</span> <span class="n">aliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">fieldname</span><span class="p">)</span>
                <span class="n">text</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">text</span>
                <span class="k">if</span> <span class="n">aname</span> <span class="ow">in</span> <span class="n">correctors</span> <span class="ow">and</span> <span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
                    <span class="c1"># Note that we use the original, not aliases fieldname here</span>
                    <span class="c1"># so if we correct the query we know what it was</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">token</span><span class="o">.</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>

        <span class="c1"># Make q query corrector</span>
        <span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">spelling</span>

        <span class="n">sqc</span> <span class="o">=</span> <span class="n">spelling</span><span class="o">.</span><span class="n">SimpleQueryCorrector</span><span class="p">(</span>
            <span class="n">correctors</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">aliases</span><span class="p">,</span> <span class="n">maxdist</span><span class="o">=</span><span class="n">maxdist</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">sqc</span><span class="o">.</span><span class="n">correct_query</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qstring</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Results"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results">[docs]</a><span class="k">class</span> <span class="nc">Results</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This object is returned by a Searcher. This object represents the</span>
<span class="sd">    results of a search query. You can mostly use it as if it was a list of</span>
<span class="sd">    dictionaries, where each dictionary is the stored fields of the document at</span>
<span class="sd">    that position in the results.</span>

<span class="sd">    Note that a Results object keeps a reference to the Searcher that created</span>
<span class="sd">    it, so keeping a reference to a Results object keeps the Searcher alive and</span>
<span class="sd">    so keeps all files used by it open.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">searcher</span><span class="p">,</span>
        <span class="n">q</span><span class="p">,</span>
        <span class="n">top_n</span><span class="p">,</span>
        <span class="n">docset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">facetmaps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">runtime</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">highlighter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param searcher: the :class:`Searcher` object that produced these</span>
<span class="sd">            results.</span>
<span class="sd">        :param query: the original query that created these results.</span>
<span class="sd">        :param top_n: a list of (score, docnum) tuples representing the top</span>
<span class="sd">            N search results.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span> <span class="o">=</span> <span class="n">searcher</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="o">=</span> <span class="n">top_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docset</span> <span class="o">=</span> <span class="n">docset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_facetmaps</span> <span class="o">=</span> <span class="n">facetmaps</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">runtime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highlighter</span> <span class="o">=</span> <span class="n">highlighter</span> <span class="ow">or</span> <span class="n">highlight</span><span class="o">.</span><span class="n">Highlighter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collector</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_char_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;Top </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">)</span><span class="si">}</span><span class="s2"> Results for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="si">!r}</span><span class="s2"> runtime=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">runtime</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the total number of documents that matched the query. Note</span>
<span class="sd">        this may be more than the number of scored documents, given the value</span>
<span class="sd">        of the ``limit`` keyword argument to :meth:`Searcher.search`.</span>

<span class="sd">        If this Results object was created by searching with a ``limit``</span>
<span class="sd">        keyword, then computing the exact length of the result set may be</span>
<span class="sd">        expensive for large indexes or large result sets. You may consider</span>
<span class="sd">        using :meth:`Results.has_exact_length`,</span>
<span class="sd">        :meth:`Results.estimated_length`, and</span>
<span class="sd">        :meth:`Results.estimated_min_length` to display an estimated size of</span>
<span class="sd">        the result set instead of an exact number.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collector</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">Hit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;results[</span><span class="si">{</span><span class="n">n</span><span class="si">!r}</span><span class="s2">]: Results only has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">)</span><span class="si">}</span><span class="s2"> hits&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">Hit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Yields a :class:`Hit` object for each result in ranked order.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">Hit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docnum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the given document number matched the query.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">docnum</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>

    <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

<div class="viewcode-block" id="Results.is_empty"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.is_empty">[docs]</a>    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if not documents matched the query.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scored_length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Results.items"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an iterator of (docnum, score) pairs for the scored</span>
<span class="sd">        documents in the results.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">((</span><span class="n">docnum</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span> <span class="k">for</span> <span class="n">score</span><span class="p">,</span> <span class="n">docnum</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">)</span></div>

<div class="viewcode-block" id="Results.fields"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.fields">[docs]</a>    <span class="k">def</span> <span class="nf">fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the stored fields for the document at the ``n`` th position</span>
<span class="sd">        in the results. Use :meth:`Results.docnum` if you want the raw</span>
<span class="sd">        document number instead of the stored fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="o">.</span><span class="n">stored_fields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Results.facet_names"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.facet_names">[docs]</a>    <span class="k">def</span> <span class="nf">facet_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the available facet names, for use with the ``groups()``</span>
<span class="sd">        method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_facetmaps</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="Results.groups"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.groups">[docs]</a>    <span class="k">def</span> <span class="nf">groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If you generated facet groupings for the results using the</span>
<span class="sd">        `groupedby` keyword argument to the ``search()`` method, you can use</span>
<span class="sd">        this method to retrieve the groups. You can use the ``facet_names()``</span>
<span class="sd">        method to get the list of available facet names.</span>

<span class="sd">        &gt;&gt;&gt; results = searcher.search(my_query, groupedby=[&quot;tag&quot;, &quot;price&quot;])</span>
<span class="sd">        &gt;&gt;&gt; results.facet_names()</span>
<span class="sd">        [&quot;tag&quot;, &quot;price&quot;]</span>
<span class="sd">        &gt;&gt;&gt; results.groups(&quot;tag&quot;)</span>
<span class="sd">        {&quot;new&quot;: [12, 1, 4], &quot;apple&quot;: [3, 10, 5], &quot;search&quot;: [11]}</span>

<span class="sd">        If you only used one facet, you can call the method without a facet</span>
<span class="sd">        name to get the groups for the facet.</span>

<span class="sd">        &gt;&gt;&gt; results = searcher.search(my_query, groupedby=&quot;tag&quot;)</span>
<span class="sd">        &gt;&gt;&gt; results.groups()</span>
<span class="sd">        {&quot;new&quot;: [12, 1, 4], &quot;apple&quot;: [3, 10, 5, 0], &quot;search&quot;: [11]}</span>

<span class="sd">        By default, this returns a dictionary mapping category names to a list</span>
<span class="sd">        of document numbers, in the same relative order as they appear in the</span>
<span class="sd">        results.</span>

<span class="sd">        &gt;&gt;&gt; results = mysearcher.search(myquery, groupedby=&quot;tag&quot;)</span>
<span class="sd">        &gt;&gt;&gt; docnums = results.groups()</span>
<span class="sd">        &gt;&gt;&gt; docnums[&#39;new&#39;]</span>
<span class="sd">        [12, 1, 4]</span>

<span class="sd">        You can then use :meth:`Searcher.stored_fields` to get the stored</span>
<span class="sd">        fields associated with a document ID.</span>

<span class="sd">        If you specified a different ``maptype`` for the facet when you</span>
<span class="sd">        searched, the values in the dictionary depend on the</span>
<span class="sd">        :class:`whoosh.sorting.FacetMap`.</span>

<span class="sd">        &gt;&gt;&gt; myfacet = sorting.FieldFacet(&quot;tag&quot;, maptype=sorting.Count)</span>
<span class="sd">        &gt;&gt;&gt; results = mysearcher.search(myquery, groupedby=myfacet)</span>
<span class="sd">        &gt;&gt;&gt; counts = results.groups()</span>
<span class="sd">        {&quot;new&quot;: 3, &quot;apple&quot;: 4, &quot;search&quot;: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;facet&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_facetmaps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If there&#39;s only one facet, just use it; convert keys() to list</span>
            <span class="c1"># for Python 3</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_facetmaps</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_facetmaps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> not in facet names </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">facet_names</span><span class="p">()</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_facetmaps</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span></div>

<div class="viewcode-block" id="Results.has_exact_length"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.has_exact_length">[docs]</a>    <span class="k">def</span> <span class="nf">has_exact_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if this results object already knows the exact number</span>
<span class="sd">        of matching documents.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collector</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">collector</span><span class="o">.</span><span class="n">computes_count</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Results.estimated_length"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.estimated_length">[docs]</a>    <span class="k">def</span> <span class="nf">estimated_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The estimated maximum number of matching documents, or the</span>
<span class="sd">        exact number of matching documents if it&#39;s known.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_exact_length</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">estimate_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="o">.</span><span class="n">reader</span><span class="p">())</span></div>

<div class="viewcode-block" id="Results.estimated_min_length"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.estimated_min_length">[docs]</a>    <span class="k">def</span> <span class="nf">estimated_min_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The estimated minimum number of matching documents, or the</span>
<span class="sd">        exact number of matching documents if it&#39;s known.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_exact_length</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">estimate_min_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="o">.</span><span class="n">reader</span><span class="p">())</span></div>

<div class="viewcode-block" id="Results.scored_length"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.scored_length">[docs]</a>    <span class="k">def</span> <span class="nf">scored_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of scored documents in the results, equal to or</span>
<span class="sd">        less than the ``limit`` keyword argument to the search.</span>

<span class="sd">        &gt;&gt;&gt; r = mysearcher.search(myquery, limit=20)</span>
<span class="sd">        &gt;&gt;&gt; len(r)</span>
<span class="sd">        1246</span>
<span class="sd">        &gt;&gt;&gt; r.scored_length()</span>
<span class="sd">        20</span>

<span class="sd">        This may be fewer than the total number of documents that match the</span>
<span class="sd">        query, which is what ``len(Results)`` returns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">)</span></div>

<div class="viewcode-block" id="Results.docs"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.docs">[docs]</a>    <span class="k">def</span> <span class="nf">docs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set-like object containing the document numbers that</span>
<span class="sd">        matched the query.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">docset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collector</span><span class="o">.</span><span class="n">all_ids</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">docset</span></div>

<div class="viewcode-block" id="Results.copy"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a deep copy of this results object.&quot;&quot;&quot;</span>

        <span class="c1"># Shallow copy self to get attributes</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Deep copies of docset and top_n in case they&#39;re modified</span>
        <span class="n">r</span><span class="o">.</span><span class="n">docset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docset</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">top_n</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span></div>

<div class="viewcode-block" id="Results.score"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the score for the document at the Nth position in the list</span>
<span class="sd">        of ranked documents. If the search was not scored, this may return</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Results.docnum"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.docnum">[docs]</a>    <span class="k">def</span> <span class="nf">docnum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the document number of the result at position n in the list</span>
<span class="sd">        of ranked documents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">query_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fieldname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">existing_terms</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="o">.</span><span class="n">reader</span><span class="p">(),</span> <span class="n">fieldname</span><span class="o">=</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="n">expand</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Results.has_matched_terms"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.has_matched_terms">[docs]</a>    <span class="k">def</span> <span class="nf">has_matched_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the search recorded which terms matched in which</span>
<span class="sd">        documents.</span>

<span class="sd">        &gt;&gt;&gt; r = searcher.search(myquery)</span>
<span class="sd">        &gt;&gt;&gt; r.has_matched_terms()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;docterms&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;termdocs&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Results.matched_terms"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.matched_terms">[docs]</a>    <span class="k">def</span> <span class="nf">matched_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the set of ``(&quot;fieldname&quot;, &quot;text&quot;)`` tuples representing</span>
<span class="sd">        terms from the query that matched one or more of the TOP N documents</span>
<span class="sd">        (this does not report terms for documents that match the query but did</span>
<span class="sd">        not score high enough to make the top N results). You can compare this</span>
<span class="sd">        set to the terms from the original query to find terms which didn&#39;t</span>
<span class="sd">        occur in any matching documents.</span>

<span class="sd">        This is only valid if you used ``terms=True`` in the search call to</span>
<span class="sd">        record matching terms. Otherwise it will raise an exception.</span>

<span class="sd">        &gt;&gt;&gt; q = myparser.parse(&quot;alfa OR bravo OR charlie&quot;)</span>
<span class="sd">        &gt;&gt;&gt; results = searcher.search(q, terms=True)</span>
<span class="sd">        &gt;&gt;&gt; results.terms()</span>
<span class="sd">        set([(&quot;content&quot;, &quot;alfa&quot;), (&quot;content&quot;, &quot;charlie&quot;)])</span>
<span class="sd">        &gt;&gt;&gt; q.all_terms() - results.terms()</span>
<span class="sd">        set([(&quot;content&quot;, &quot;bravo&quot;)])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_matched_terms</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">NoTermsException</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">termdocs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_get_fragmenter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">highlighter</span><span class="o">.</span><span class="n">fragmenter</span>

    <span class="k">def</span> <span class="nf">_set_fragmenter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highlighter</span><span class="o">.</span><span class="n">fragmenter</span> <span class="o">=</span> <span class="n">f</span>

    <span class="n">fragmenter</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_fragmenter</span><span class="p">,</span> <span class="n">_set_fragmenter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">highlighter</span><span class="o">.</span><span class="n">formatter</span>

    <span class="k">def</span> <span class="nf">_set_formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highlighter</span><span class="o">.</span><span class="n">formatter</span> <span class="o">=</span> <span class="n">f</span>

    <span class="n">formatter</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_formatter</span><span class="p">,</span> <span class="n">_set_formatter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_scorer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">highlighter</span><span class="o">.</span><span class="n">scorer</span>

    <span class="k">def</span> <span class="nf">_set_scorer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highlighter</span><span class="o">.</span><span class="n">scorer</span> <span class="o">=</span> <span class="n">s</span>

    <span class="n">scorer</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_scorer</span><span class="p">,</span> <span class="n">_set_scorer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">highlighter</span><span class="o">.</span><span class="n">order</span>

    <span class="k">def</span> <span class="nf">_set_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highlighter</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">o</span>

    <span class="n">order</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_order</span><span class="p">,</span> <span class="n">_set_order</span><span class="p">)</span>

<div class="viewcode-block" id="Results.key_terms"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.key_terms">[docs]</a>    <span class="k">def</span> <span class="nf">key_terms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">docs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">numterms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">classify</span><span class="o">.</span><span class="n">Bo1Model</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the &#39;numterms&#39; most important terms from the top &#39;docs&#39;</span>
<span class="sd">        documents in these results. &quot;Most important&quot; is generally defined as</span>
<span class="sd">        terms that occur frequently in the top hits but relatively infrequently</span>
<span class="sd">        in the collection as a whole.</span>

<span class="sd">        :param fieldname: Look at the terms in this field. This field must</span>
<span class="sd">            store vectors.</span>
<span class="sd">        :param docs: Look at this many of the top documents of the results.</span>
<span class="sd">        :param numterms: Return this number of important terms.</span>
<span class="sd">        :param model: The classify.ExpansionModel to use. See the classify</span>
<span class="sd">            module.</span>
<span class="sd">        :returns: list of unicode strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">docs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span>

        <span class="n">expander</span> <span class="o">=</span> <span class="n">classify</span><span class="o">.</span><span class="n">Expander</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">docnum</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">[:</span><span class="n">docs</span><span class="p">]:</span>
            <span class="n">expander</span><span class="o">.</span><span class="n">add_document</span><span class="p">(</span><span class="n">docnum</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expander</span><span class="o">.</span><span class="n">expanded_terms</span><span class="p">(</span><span class="n">numterms</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">)</span></div>

<div class="viewcode-block" id="Results.extend"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Appends hits from &#39;results&#39; (that are not already in this</span>
<span class="sd">        results object) to the end of these results.</span>

<span class="sd">        :param results: another results object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">top_n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docset</span> <span class="o">=</span> <span class="n">docs</span> <span class="o">|</span> <span class="n">results</span><span class="o">.</span><span class="n">docs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docset</span><span class="p">)</span></div>

<div class="viewcode-block" id="Results.filter"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes any hits that are not also in the other results object.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">otherdocs</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">docs</span><span class="p">()</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">otherdocs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">otherdocs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="o">=</span> <span class="n">items</span></div>

<div class="viewcode-block" id="Results.upgrade"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.upgrade">[docs]</a>    <span class="k">def</span> <span class="nf">upgrade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-sorts the results so any hits that are also in &#39;results&#39; appear</span>
<span class="sd">        before hits not in &#39;results&#39;, otherwise keeping their current relative</span>
<span class="sd">        positions. This does not add the documents in the other results object</span>
<span class="sd">        to this one.</span>

<span class="sd">        :param results: another results object.</span>
<span class="sd">        :param reverse: if True, lower the position of hits in the other</span>
<span class="sd">            results object instead of raising them.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">otherdocs</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">docs</span><span class="p">()</span>
        <span class="n">arein</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">otherdocs</span><span class="p">]</span>
        <span class="n">notin</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">otherdocs</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">notin</span> <span class="o">+</span> <span class="n">arein</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">arein</span> <span class="o">+</span> <span class="n">notin</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="o">=</span> <span class="n">items</span></div>

<div class="viewcode-block" id="Results.upgrade_and_extend"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Results.upgrade_and_extend">[docs]</a>    <span class="k">def</span> <span class="nf">upgrade_and_extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combines the effects of extend() and upgrade(): hits that are also</span>
<span class="sd">        in &#39;results&#39; are raised. Then any hits from the other results object</span>
<span class="sd">        that are not in this results object are appended to the end.</span>

<span class="sd">        :param results: another results object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">()</span>
        <span class="n">otherdocs</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">docs</span><span class="p">()</span>

        <span class="n">arein</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">otherdocs</span><span class="p">]</span>
        <span class="n">notin</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">otherdocs</span><span class="p">]</span>
        <span class="n">other</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">top_n</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">docset</span> <span class="o">=</span> <span class="n">docs</span> <span class="o">|</span> <span class="n">otherdocs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="o">=</span> <span class="n">arein</span> <span class="o">+</span> <span class="n">notin</span> <span class="o">+</span> <span class="n">other</span></div></div>


<div class="viewcode-block" id="Hit"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Hit">[docs]</a><span class="k">class</span> <span class="nc">Hit</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a single search result (&quot;hit&quot;) in a Results object.</span>

<span class="sd">    This object acts like a dictionary of the matching document&#39;s stored</span>
<span class="sd">    fields. If for some reason you need an actual ``dict`` object, use</span>
<span class="sd">    ``Hit.fields()`` to get one.</span>

<span class="sd">    &gt;&gt;&gt; r = searcher.search(query.Term(&quot;content&quot;, &quot;render&quot;))</span>
<span class="sd">    &gt;&gt;&gt; r[0]</span>
<span class="sd">    &lt; Hit {title = u&quot;Rendering the scene&quot;} &gt;</span>
<span class="sd">    &gt;&gt;&gt; r[0].rank</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; r[0].docnum == 4592</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; r[0].score</span>
<span class="sd">    2.52045682</span>
<span class="sd">    &gt;&gt;&gt; r[0][&quot;title&quot;]</span>
<span class="sd">    &quot;Rendering the scene&quot;</span>
<span class="sd">    &gt;&gt;&gt; r[0].keys()</span>
<span class="sd">    [&quot;title&quot;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">docnum</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param results: the Results object this hit belongs to.</span>
<span class="sd">        :param pos: the position in the results list of this hit, for example</span>
<span class="sd">            pos = 0 means this is the first (highest scoring) hit.</span>
<span class="sd">        :param docnum: the document number of this hit.</span>
<span class="sd">        :param score: the score of this hit.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">searcher</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="o">.</span><span class="n">reader</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docnum</span> <span class="o">=</span> <span class="n">docnum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Hit.fields"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Hit.fields">[docs]</a>    <span class="k">def</span> <span class="nf">fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a dictionary of the stored fields of the document this</span>
<span class="sd">        object represents.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="o">.</span><span class="n">stored_fields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docnum</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span></div>

<div class="viewcode-block" id="Hit.matched_terms"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Hit.matched_terms">[docs]</a>    <span class="k">def</span> <span class="nf">matched_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the set of ``(&quot;fieldname&quot;, &quot;text&quot;)`` tuples representing</span>
<span class="sd">        terms from the query that matched in this document. You can</span>
<span class="sd">        compare this set to the terms from the original query to find terms</span>
<span class="sd">        which didn&#39;t occur in this document.</span>

<span class="sd">        This is only valid if you used ``terms=True`` in the search call to</span>
<span class="sd">        record matching terms. Otherwise it will raise an exception.</span>

<span class="sd">        &gt;&gt;&gt; q = myparser.parse(&quot;alfa OR bravo OR charlie&quot;)</span>
<span class="sd">        &gt;&gt;&gt; results = searcher.search(q, terms=True)</span>
<span class="sd">        &gt;&gt;&gt; for hit in results:</span>
<span class="sd">        ...   print(hit[&quot;title&quot;])</span>
<span class="sd">        ...   print(&quot;Contains:&quot;, hit.matched_terms())</span>
<span class="sd">        ...   print(&quot;Doesn&#39;t contain:&quot;, q.all_terms() - hit.matched_terms())</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">has_matched_terms</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">NoTermsException</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">docterms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docnum</span><span class="p">,</span> <span class="p">[])</span></div>

<div class="viewcode-block" id="Hit.highlights"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Hit.highlights">[docs]</a>    <span class="k">def</span> <span class="nf">highlights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">minscore</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">strict_phrase</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns highlighted snippets from the given field::</span>

<span class="sd">            r = searcher.search(myquery)</span>
<span class="sd">            for hit in r:</span>
<span class="sd">                print(hit[&quot;title&quot;])</span>
<span class="sd">                print(hit.highlights(&quot;content&quot;))</span>

<span class="sd">        See :doc:`/highlight`.</span>

<span class="sd">        To change the fragmeter, formatter, order, or scorer used in</span>
<span class="sd">        highlighting, you can set attributes on the results object::</span>

<span class="sd">            from whoosh import highlight</span>

<span class="sd">            results = searcher.search(myquery, terms=True)</span>
<span class="sd">            results.fragmenter = highlight.SentenceFragmenter()</span>

<span class="sd">        ...or use a custom :class:`whoosh.highlight.Highlighter` object::</span>

<span class="sd">            hl = highlight.Highlighter(fragmenter=sf)</span>
<span class="sd">            results.highlighter = hl</span>

<span class="sd">        :param fieldname: the name of the field you want to highlight.</span>
<span class="sd">        :param text: by default, the method will attempt to load the contents</span>
<span class="sd">            of the field from the stored fields for the document. If the field</span>
<span class="sd">            you want to highlight isn&#39;t stored in the index, but you have</span>
<span class="sd">            access to the text another way (for example, loading from a file or</span>
<span class="sd">            a database), you can supply it using the ``text`` parameter.</span>
<span class="sd">        :param top: the maximum number of fragments to return.</span>
<span class="sd">        :param minscore: the minimum score for fragments to appear in the</span>
<span class="sd">            highlights.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">hliter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">highlighter</span>
        <span class="k">return</span> <span class="n">hliter</span><span class="o">.</span><span class="n">highlight_hit</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fieldname</span><span class="p">,</span>
            <span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span>
            <span class="n">top</span><span class="o">=</span><span class="n">top</span><span class="p">,</span>
            <span class="n">minscore</span><span class="o">=</span><span class="n">minscore</span><span class="p">,</span>
            <span class="n">strict_phrase</span><span class="o">=</span><span class="n">strict_phrase</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hit.more_like_this"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.Hit.more_like_this">[docs]</a>    <span class="k">def</span> <span class="nf">more_like_this</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fieldname</span><span class="p">,</span>
        <span class="n">text</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">top</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">numterms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">classify</span><span class="o">.</span><span class="n">Bo1Model</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new Results object containing documents similar to this</span>
<span class="sd">        hit, based on &quot;key terms&quot; in the given field::</span>

<span class="sd">            r = searcher.search(myquery)</span>
<span class="sd">            for hit in r:</span>
<span class="sd">                print(hit[&quot;title&quot;])</span>
<span class="sd">                print(&quot;Top 3 similar documents:&quot;)</span>
<span class="sd">                for subhit in hit.more_like_this(&quot;content&quot;, top=3):</span>
<span class="sd">                  print(&quot;  &quot;, subhit[&quot;title&quot;])</span>

<span class="sd">        :param fieldname: the name of the field to use to test similarity.</span>
<span class="sd">        :param text: by default, the method will attempt to load the contents</span>
<span class="sd">            of the field from the stored fields for the document, or from a</span>
<span class="sd">            term vector. If the field isn&#39;t stored or vectored in the index,</span>
<span class="sd">            but you have access to the text another way (for example, loading</span>
<span class="sd">            from a file or a database), you can supply it using the ``text``</span>
<span class="sd">            parameter.</span>
<span class="sd">        :param top: the number of results to return.</span>
<span class="sd">        :param numterms: the number of &quot;key terms&quot; to extract from the hit and</span>
<span class="sd">            search for. Using more terms is slower but gives potentially more</span>
<span class="sd">            and more accurate results.</span>
<span class="sd">        :param model: (expert) a :class:`whoosh.classify.ExpansionModel` to use</span>
<span class="sd">            to compute &quot;key terms&quot;.</span>
<span class="sd">        :param normalize: whether to normalize term weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="o">.</span><span class="n">more_like</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docnum</span><span class="p">,</span>
            <span class="n">fieldname</span><span class="p">,</span>
            <span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span>
            <span class="n">top</span><span class="o">=</span><span class="n">top</span><span class="p">,</span>
            <span class="n">numterms</span><span class="o">=</span><span class="n">numterms</span><span class="p">,</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
            <span class="nb">filter</span><span class="o">=</span><span class="nb">filter</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="si">!r}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Hit</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>

        <span class="n">reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span>
        <span class="k">if</span> <span class="n">reader</span><span class="o">.</span><span class="n">has_column</span><span class="p">(</span><span class="n">fieldname</span><span class="p">):</span>
            <span class="n">cr</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">column_reader</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">docnum</span><span class="p">]</span>

        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">has_column</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You cannot modify a search result&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ResultsPage"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.ResultsPage">[docs]</a><span class="k">class</span> <span class="nc">ResultsPage</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a single page out of a longer list of results, as returned</span>
<span class="sd">    by :func:`whoosh.searching.Searcher.search_page`. Supports a subset of the</span>
<span class="sd">    interface of the :class:`~whoosh.searching.Results` object, namely getting</span>
<span class="sd">    stored fields with __getitem__ (square brackets), iterating, and the</span>
<span class="sd">    ``score()`` and ``docnum()`` methods.</span>

<span class="sd">    The ``offset`` attribute contains the results number this page starts at</span>
<span class="sd">    (numbered from 0). For example, if the page length is 10, the ``offset``</span>
<span class="sd">    attribute on the second page will be ``10``.</span>

<span class="sd">    The ``pagecount`` attribute contains the number of pages available.</span>

<span class="sd">    The ``pagenum`` attribute contains the page number. This may be less than</span>
<span class="sd">    the page you requested if the results had too few pages. For example, if</span>
<span class="sd">    you do::</span>

<span class="sd">        ResultsPage(results, 5)</span>

<span class="sd">    but the results object only contains 3 pages worth of hits, ``pagenum``</span>
<span class="sd">    will be 3.</span>

<span class="sd">    The ``pagelen`` attribute contains the number of results on this page</span>
<span class="sd">    (which may be less than the page length you requested if this is the last</span>
<span class="sd">    page of the results).</span>

<span class="sd">    The ``total`` attribute contains the total number of hits in the results.</span>

<span class="sd">    &gt;&gt;&gt; mysearcher = myindex.searcher()</span>
<span class="sd">    &gt;&gt;&gt; pagenum = 2</span>
<span class="sd">    &gt;&gt;&gt; page = mysearcher.find_page(pagenum, myquery)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Page %s of %s, results %s to %s of %s&quot; %</span>
<span class="sd">    ...       (pagenum, page.pagecount, page.offset+1,</span>
<span class="sd">    ...        page.offset+page.pagelen, page.total))</span>
<span class="sd">    &gt;&gt;&gt; for i, fields in enumerate(page):</span>
<span class="sd">    ...   print(&quot;%s. %r&quot; % (page.offset + i + 1, fields))</span>
<span class="sd">    &gt;&gt;&gt; mysearcher.close()</span>

<span class="sd">    To set highlighter attributes (for example ``formatter``), access the</span>
<span class="sd">    underlying :class:`Results` object::</span>

<span class="sd">        page.results.formatter = highlight.UppercaseFormatter()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">pagenum</span><span class="p">,</span> <span class="n">pagelen</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param results: a :class:`~whoosh.searching.Results` object.</span>
<span class="sd">        :param pagenum: which page of the results to use, numbered from ``1``.</span>
<span class="sd">        :param pagelen: the number of hits per page.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pagenum</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pagenum must be &gt;= 1&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pagecount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">/</span> <span class="n">pagelen</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pagenum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pagecount</span><span class="p">,</span> <span class="n">pagenum</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pagenum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pagelen</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">pagelen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">total</span><span class="p">:</span>
            <span class="n">pagelen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">-</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pagelen</span> <span class="o">=</span> <span class="n">pagelen</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pagelen</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pagelen</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total</span>

    <span class="k">def</span> <span class="nf">scored_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">scored_length</span><span class="p">()</span>

<div class="viewcode-block" id="ResultsPage.score"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.ResultsPage.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the score of the hit at the nth position on this page.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span></div>

<div class="viewcode-block" id="ResultsPage.docnum"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.ResultsPage.docnum">[docs]</a>    <span class="k">def</span> <span class="nf">docnum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the document number of the hit at the nth position on this</span>
<span class="sd">        page.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">docnum</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span></div>

<div class="viewcode-block" id="ResultsPage.is_last_page"><a class="viewcode-back" href="../../api/searching.html#whoosh.searching.ResultsPage.is_last_page">[docs]</a>    <span class="k">def</span> <span class="nf">is_last_page</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if this object represents the last page of results.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pagecount</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pagenum</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">pagecount</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2007-2012 Matt Chaput.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>